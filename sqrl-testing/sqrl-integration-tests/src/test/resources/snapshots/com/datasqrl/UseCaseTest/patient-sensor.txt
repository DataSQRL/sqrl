>>>pipeline_explain.txt
=== lastHour
ID:     lasthour$1
Type:   stream
Stage:  streams
Inputs: observationgroup$2, patientlasthour$1
Primary Key: __pk1$groupId, __pk3$created
Timestamp  : __pk3$created
Schema:
 - __pk1$groupId: BIGINT NOT NULL
 - __pk3$created: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - maxTemp: DECIMAL(10, 5) NOT NULL
 - minTemp: DECIMAL(10, 5) NOT NULL
Plan:
LogicalProject(__pk1$groupId=[$0], __pk3$created=[$1], maxTemp=[$2], minTemp=[$3])
  LogicalAggregate(group=[{0, 2}], maxTemp=[MAX($8)], minTemp=[MIN($9)]) hints[TumbleAggregationHint options:[2, INSTANT, 2, 1, 0]]
    LogicalJoin(condition=[=($5, $6)], joinType=[inner]) hints[TemporalJoinHint options:[2]]
      LogicalCorrelate(correlation=[$cor3], joinType=[inner], requiredColumns=[{3}])
        LogicalTableScan(table=[[observationgroup$2]])
        LogicalTableFunctionScan(invocation=[ObservationGroup.patients($cor3.patients)], rowType=[RecordType(INTEGER _idx, BIGINT patientId)], elementType=[class [Ljava.lang.Object;])
      LogicalFilter(condition=[=($5, 1)]) hints[DedupHint]
        LogicalProject(patientid=[$0], avgTemp=[$1], maxTemp=[$2], minTemp=[$3], _timeMin=[$4], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $4 DESC NULLS LAST)])
          LogicalTableScan(table=[[patientlasthour$1]])

=== ObservationGroup
ID:     observationgroup$2
Type:   stream
Stage:  streams
Primary Key: groupId, created
Timestamp  : created
Schema:
 - groupId: BIGINT NOT NULL
 - groupName: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - created: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - patients: RecordType(INTEGER NOT NULL _idx, BIGINT NOT NULL patientId) NOT NULL ARRAY NOT NULL
Plan:
LogicalTableScan(table=[[observationgroup$1]], hints=[[[WatermarkHint inheritPath:[] options:[2]]]]) hints[WatermarkHint options:[2]]

=== PatientHourly
ID:     patienthourly$1
Type:   stream
Stage:  streams
Inputs: sensors$3, smoothreading$1
Primary Key: patientid, timeHour
Timestamp  : timeHour
Schema:
 - patientid: BIGINT NOT NULL
 - timeHour: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - avgTemp: DECIMAL(10, 5) NOT NULL
 - maxTemp: DECIMAL(10, 5) NOT NULL
 - minTemp: DECIMAL(10, 5) NOT NULL
Plan:
LogicalAggregate(group=[{0, 1}], avgTemp=[AVG($2)], maxTemp=[MAX($2)], minTemp=[MIN($2)]) hints[TumbleAggregationHint options:[1, FUNCTION, 4, 3600000, 0]]
  LogicalProject(patientid=[$5], timeHour=[endOfHour($1)], smoothTemp=[$2], sensorid=[$0], timeMin=[$1])
    LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
      LogicalProject(sensorid=[$0], timeMin=[$1], smoothTemp=[$2], sensorid3=[$0])
        LogicalTableScan(table=[[smoothreading$1]])
      LogicalFilter(condition=[=($4, 1)]) hints[DedupHint]
        LogicalProject(id=[$0], patientid=[$1], placed=[$2], placedTimestamp=[$3], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $3 DESC NULLS LAST)])
          LogicalTableScan(table=[[sensors$3]])

=== PatientLastHour
ID:     patientlasthour$1
Type:   state
Stage:  streams
Inputs: sensors$3, smoothreading$1
Primary Key: patientid
Timestamp  : _timeMin
Schema:
 - patientid: BIGINT NOT NULL
 - avgTemp: DECIMAL(10, 5) NOT NULL
 - maxTemp: DECIMAL(10, 5) NOT NULL
 - minTemp: DECIMAL(10, 5) NOT NULL
 - _timeMin: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=patientid limit=1 sort=#4: _timeMin TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalProject(patientid=[$1], avgTemp=[$2], maxTemp=[$3], minTemp=[$4], _timeMin=[$0])
  LogicalAggregate(group=[{1, 5}], avgTemp=[AVG($2)], maxTemp=[MAX($2)], minTemp=[MIN($2)]) hints[SlidingAggregationHint options:[1, 3600000, 72000]]
    LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
      LogicalProject(sensorid=[$0], timeMin=[$1], smoothTemp=[$2], sensorid3=[$0])
        LogicalTableScan(table=[[smoothreading$1]])
      LogicalFilter(condition=[=($4, 1)]) hints[DedupHint]
        LogicalProject(id=[$0], patientid=[$1], placed=[$2], placedTimestamp=[$3], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $3 DESC NULLS LAST)])
          LogicalTableScan(table=[[sensors$3]])

=== SensorReading
ID:     sensorreading$2
Type:   stream
Stage:  streams
Primary Key: _uuid
Timestamp  : event_time
Schema:
 - sensorid: BIGINT NOT NULL
 - temperature: DECIMAL(10, 5) NOT NULL
 - _uuid: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - event_time: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalTableScan(table=[[sensorreading$1]], hints=[[[WatermarkHint inheritPath:[] options:[3]]]]) hints[WatermarkHint options:[3]]

=== Sensors
ID:     sensors$2
Type:   stream
Stage:  streams
Primary Key: id, placed
Timestamp  : placedTimestamp
Schema:
 - id: BIGINT NOT NULL
 - patientid: BIGINT NOT NULL
 - placed: BIGINT NOT NULL
 - placedTimestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalTableScan(table=[[sensors$1]], hints=[[[WatermarkHint inheritPath:[] options:[3]]]]) hints[WatermarkHint options:[3]]

=== Sensors
ID:     sensors$3
Type:   state
Stage:  streams
Inputs: sensors$2
Primary Key: id
Timestamp  : placedTimestamp
Schema:
 - id: BIGINT NOT NULL
 - patientid: BIGINT NOT NULL
 - placed: BIGINT NOT NULL
 - placedTimestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=id limit=1 sort=#3: placedTimestamp TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalTableScan(table=[[sensors$2]])

=== SmoothReading
ID:     smoothreading$1
Type:   stream
Stage:  streams
Inputs: sensorreading$2
Primary Key: sensorid, timeMin
Timestamp  : timeMin
Schema:
 - sensorid: BIGINT NOT NULL
 - timeMin: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - smoothTemp: DECIMAL(10, 5) NOT NULL
Plan:
LogicalAggregate(group=[{0, 1}], smoothTemp=[AVG($2)]) hints[TumbleAggregationHint options:[1, FUNCTION, 4, 60000, 0]]
  LogicalProject(sensorid=[$0], timeMin=[endOfMinute($3)], temperature=[$1], _uuid=[$2], event_time=[$3])
    LogicalTableScan(table=[[sensorreading$2]])

=== TempAlert
ID:     tempalert$1
Type:   stream
Stage:  streams
Inputs: sensors$3, smoothreading$1
Primary Key: sensorid, timeMin
Timestamp  : timeMin
Schema:
 - patientid: BIGINT NOT NULL
 - sensorid: BIGINT NOT NULL
 - smoothTemp: DECIMAL(10, 5) NOT NULL
 - timeMin: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalProject(patientid=[$5], sensorid=[$0], smoothTemp=[$2], timeMin=[$1])
  LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
    LogicalProject(sensorid=[$0], timeMin=[$1], smoothTemp=[$2], sensorid3=[$0])
      LogicalFilter(condition=[SEARCH($2, Sarg[(-∞..95), (102..+∞)])])
        LogicalTableScan(table=[[smoothreading$1]])
    LogicalFilter(condition=[=($4, 1)]) hints[DedupHint]
      LogicalProject(id=[$0], patientid=[$1], placed=[$2], placedTimestamp=[$3], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $3 DESC NULLS LAST)])
        LogicalTableScan(table=[[sensors$3]])

=== print.tempWarning.tempWarning
ID:     tempalert$1$1
Type:   export
Stage:  streams
Inputs: tempalert$1

=== TempAlert.TempAlert
ID:     tempalert$1$2
Type:   export
Stage:  streams
Inputs: tempalert$1

>>>database-schema.sql
CREATE TABLE IF NOT EXISTS lasthour$1 ("__pk1$groupId" BIGINT NOT NULL,"__pk3$created" TIMESTAMP WITH TIME ZONE NOT NULL,"maxTemp" NUMERIC NOT NULL,"minTemp" NUMERIC NOT NULL , PRIMARY KEY ("__pk1$groupId","__pk3$created"));
CREATE TABLE IF NOT EXISTS observationgroup$2 ("groupId" BIGINT NOT NULL,"groupName" TEXT NOT NULL,"created" TIMESTAMP WITH TIME ZONE NOT NULL,"patients" JSONB NOT NULL , PRIMARY KEY ("groupId","created"));
CREATE TABLE IF NOT EXISTS patienthourly$1 ("patientid" BIGINT NOT NULL,"timeHour" TIMESTAMP WITH TIME ZONE NOT NULL,"avgTemp" NUMERIC NOT NULL,"maxTemp" NUMERIC NOT NULL,"minTemp" NUMERIC NOT NULL , PRIMARY KEY ("patientid","timeHour"));
CREATE TABLE IF NOT EXISTS patientlasthour$1 ("patientid" BIGINT NOT NULL,"avgTemp" NUMERIC NOT NULL,"maxTemp" NUMERIC NOT NULL,"minTemp" NUMERIC NOT NULL,"_timeMin" TIMESTAMP WITH TIME ZONE NOT NULL , PRIMARY KEY ("patientid"));
>>>flink-plan.sql
CREATE TEMPORARY FUNCTION IF NOT EXISTS `timestamptostring` AS 'com.datasqrl.time.TimestampToString' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofmonth` AS 'com.datasqrl.time.EndOfMonth' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofweek` AS 'com.datasqrl.time.EndOfWeek' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `parsetimestamp` AS 'com.datasqrl.time.ParseTimestamp' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `epochmillitotimestamp` AS 'com.datasqrl.time.EpochMilliToTimestamp' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofminute` AS 'com.datasqrl.time.EndOfMinute' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `timestamptoepoch` AS 'com.datasqrl.time.TimestampToEpoch' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofsecond` AS 'com.datasqrl.time.EndOfSecond' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `epochtotimestamp` AS 'com.datasqrl.time.EpochToTimestamp' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofday` AS 'com.datasqrl.time.EndOfDay' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `atzone` AS 'com.datasqrl.time.AtZone' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofhour` AS 'com.datasqrl.time.EndOfHour' LANGUAGE JAVA;

CREATE TEMPORARY FUNCTION IF NOT EXISTS `endofyear` AS 'com.datasqrl.time.EndOfYear' LANGUAGE JAVA;

CREATE TEMPORARY TABLE `observationgroup$1` (
  `groupId` BIGINT NOT NULL,
  `groupName` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `created` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `patients` ROW(`_idx` INTEGER NOT NULL, `patientId` BIGINT NOT NULL) NOT NULL ARRAY NOT NULL,
  PRIMARY KEY (`groupId`, `created`) NOT ENFORCED,
  WATERMARK FOR `created` AS (`created` - INTERVAL '0.001' SECOND)
) WITH (
  'format' = 'json',
  'path' = '/mnt/build/data',
  'source.monitor-interval' = '0',
  'connector' = 'filesystem',
  'source.path.regex-pattern' = 'to be determined'
);

CREATE TEMPORARY TABLE `sensors$1` (
  `id` BIGINT NOT NULL,
  `patientid` BIGINT NOT NULL,
  `placed` BIGINT NOT NULL,
  `placedTimestamp` AS EPOCHMILLITOTIMESTAMP(`placed`),
  PRIMARY KEY (`id`, `placed`) NOT ENFORCED,
  WATERMARK FOR `placedTimestamp` AS (`placedTimestamp` - INTERVAL '0.001' SECOND)
) WITH (
  'format' = 'json',
  'path' = '/mnt/build/data',
  'source.monitor-interval' = '0',
  'connector' = 'filesystem',
  'source.path.regex-pattern' = 'to be determined'
);

CREATE TEMPORARY TABLE `sensorreading$1` (
  `sensorid` BIGINT NOT NULL,
  `temperature` DECIMAL(10, 5) NOT NULL,
  `_uuid` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL METADATA FROM 'timestamp',
  WATERMARK FOR `event_time` AS (`event_time` - INTERVAL '0.0' SECOND)
) WITH (
  'properties.bootstrap.servers' = 'kafka:9092',
  'properties.auto.offset.reset' = 'earliest',
  'connector' = 'kafka',
  'format' = 'json',
  'properties.group.id' = 'groupid',
  'topic' = 'patient-sensor-addreading',
  'scan.startup.mode' = 'earliest-offset'
);

CREATE TEMPORARY TABLE `lasthour$1` (
  `__pk1$groupId` BIGINT NOT NULL,
  `__pk3$created` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `maxTemp` DECIMAL(10, 5) NOT NULL,
  `minTemp` DECIMAL(10, 5) NOT NULL,
  PRIMARY KEY (`__pk1$groupId`, `__pk3$created`) NOT ENFORCED
) WITH (
  'password' = 'postgres',
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'table-name' = 'lasthour$1',
  'user' = 'postgres',
  'url' = 'jdbc:postgresql://database:5432/datasqrl'
);

CREATE TEMPORARY TABLE `observationgroup$2` (
  `groupId` BIGINT NOT NULL,
  `groupName` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `created` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `patients` ROW(`_idx` INTEGER NOT NULL, `patientId` BIGINT NOT NULL) NOT NULL ARRAY NOT NULL,
  PRIMARY KEY (`groupId`, `created`) NOT ENFORCED
) WITH (
  'password' = 'postgres',
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'table-name' = 'observationgroup$2',
  'user' = 'postgres',
  'url' = 'jdbc:postgresql://database:5432/datasqrl'
);

CREATE TEMPORARY TABLE `patienthourly$1` (
  `patientid` BIGINT NOT NULL,
  `timeHour` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `avgTemp` DECIMAL(10, 5) NOT NULL,
  `maxTemp` DECIMAL(10, 5) NOT NULL,
  `minTemp` DECIMAL(10, 5) NOT NULL,
  PRIMARY KEY (`patientid`, `timeHour`) NOT ENFORCED
) WITH (
  'password' = 'postgres',
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'table-name' = 'patienthourly$1',
  'user' = 'postgres',
  'url' = 'jdbc:postgresql://database:5432/datasqrl'
);

CREATE TEMPORARY TABLE `patientlasthour$1` (
  `patientid` BIGINT NOT NULL,
  `avgTemp` DECIMAL(10, 5) NOT NULL,
  `maxTemp` DECIMAL(10, 5) NOT NULL,
  `minTemp` DECIMAL(10, 5) NOT NULL,
  `_timeMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`patientid`) NOT ENFORCED
) WITH (
  'password' = 'postgres',
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'table-name' = 'patientlasthour$1',
  'user' = 'postgres',
  'url' = 'jdbc:postgresql://database:5432/datasqrl'
);

CREATE TEMPORARY TABLE `tempalert$1$1` (
  `patientid` BIGINT NOT NULL,
  `sensorid` BIGINT NOT NULL,
  `smoothTemp` DECIMAL(10, 5) NOT NULL,
  `timeMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL
) WITH (
  'connector' = 'print',
  'print-identifier' = 'tempWarning'
);

CREATE TEMPORARY TABLE `tempalert$1$2` (
  `patientid` BIGINT NOT NULL,
  `sensorid` BIGINT NOT NULL,
  `smoothTemp` DECIMAL(10, 5) NOT NULL,
  `timeMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL
) WITH (
  'properties.bootstrap.servers' = 'kafka:9092',
  'properties.auto.offset.reset' = 'earliest',
  'connector' = 'kafka',
  'format' = 'json',
  'properties.group.id' = 'groupid',
  'topic' = 'tempalert-1',
  'scan.startup.mode' = 'earliest-offset'
);

CREATE VIEW `table$1`
AS
SELECT *
FROM (SELECT `id`, `patientid`, `placed`, `placedTimestamp`, (ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `placedTimestamp` DESC NULLS LAST)) AS `_rownum`
FROM `sensors$1`) AS `t`
WHERE (`_rownum` = 1);

CREATE VIEW `table$2`
AS
SELECT `sensorid`, ENDOFMINUTE(`event_time`) AS `timeMin`, `temperature`, `_uuid`, `event_time`
FROM `sensorreading$1`;

CREATE VIEW `table$3`
AS
SELECT *
FROM (SELECT `sensorid`, `window_time` AS `timeMin`, AVG(`temperature`) AS `smoothTemp`, `sensorid` AS `sensorid3`
FROM TABLE(TUMBLE((TABLE `table$2`), (DESCRIPTOR(`event_time`)), INTERVAL '60' SECOND(5), INTERVAL '0' SECOND(1))) AS `t2`
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`) AS `$cor5`
INNER JOIN `table$1` FOR SYSTEM_TIME AS OF `$cor5`.`timeMin` AS `t0` ON (`t0`.`id` = `$cor5`.`sensorid3`);

CREATE VIEW `table$4`
AS
SELECT *
FROM (SELECT `patientid`, `avgTemp`, `maxTemp`, `minTemp`, `_timeMin`, (ROW_NUMBER() OVER (PARTITION BY `patientid` ORDER BY `_timeMin` DESC NULLS LAST)) AS `_rownum`
FROM (SELECT `patientid`, AVG(`smoothTemp`) AS `avgTemp`, MAX(`smoothTemp`) AS `maxTemp`, MIN(`smoothTemp`) AS `minTemp`, `window_time` AS `_timeMin`
FROM TABLE(HOP((TABLE `table$3`), (DESCRIPTOR(`timeMin`)), INTERVAL '72' SECOND(5), INTERVAL '3600' SECOND(7))) AS `t6`
GROUP BY `patientid`, `window_start`, `window_end`, `window_time`) AS `t9`) AS `t10`
WHERE (`_rownum` = 1);

CREATE VIEW `table$5`
AS
SELECT *
FROM (SELECT *
FROM `observationgroup$1` AS `$cor3`,
UNNEST(`$cor3`.`patients`) AS `t130`) AS `$cor4`
INNER JOIN `table$4` FOR SYSTEM_TIME AS OF `$cor4`.`created` AS `t11` ON (`$cor4`.`patientId` = `t11`.`patientid`);

CREATE VIEW `table$6`
AS
SELECT *
FROM (SELECT `id`, `patientid`, `placed`, `placedTimestamp`, (ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `placedTimestamp` DESC NULLS LAST)) AS `_rownum`
FROM `sensors$1`) AS `t`
WHERE (`_rownum` = 1);

CREATE VIEW `table$7`
AS
SELECT `sensorid`, ENDOFMINUTE(`event_time`) AS `timeMin`, `temperature`, `_uuid`, `event_time`
FROM `sensorreading$1`;

CREATE VIEW `table$8`
AS
SELECT `t0`.`patientid`, ENDOFHOUR(`$cor6`.`timeMin`) AS `timeHour`, `$cor6`.`smoothTemp`, `$cor6`.`sensorid`, `$cor6`.`timeMin`
FROM (SELECT `sensorid`, `window_time` AS `timeMin`, AVG(`temperature`) AS `smoothTemp`, `sensorid` AS `sensorid3`
FROM TABLE(TUMBLE((TABLE `table$7`), (DESCRIPTOR(`event_time`)), INTERVAL '60' SECOND(5), INTERVAL '0' SECOND(1))) AS `t2`
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`) AS `$cor6`
INNER JOIN `table$6` FOR SYSTEM_TIME AS OF `$cor6`.`timeMin` AS `t0` ON (`t0`.`id` = `$cor6`.`sensorid3`);

CREATE VIEW `table$9`
AS
SELECT *
FROM (SELECT `id`, `patientid`, `placed`, `placedTimestamp`, (ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `placedTimestamp` DESC NULLS LAST)) AS `_rownum`
FROM `sensors$1`) AS `t`
WHERE (`_rownum` = 1);

CREATE VIEW `table$10`
AS
SELECT `sensorid`, ENDOFMINUTE(`event_time`) AS `timeMin`, `temperature`, `_uuid`, `event_time`
FROM `sensorreading$1`;

CREATE VIEW `table$11`
AS
SELECT *
FROM (SELECT `sensorid`, `window_time` AS `timeMin`, AVG(`temperature`) AS `smoothTemp`, `sensorid` AS `sensorid3`
FROM TABLE(TUMBLE((TABLE `table$10`), (DESCRIPTOR(`event_time`)), INTERVAL '60' SECOND(5), INTERVAL '0' SECOND(1))) AS `t2`
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`) AS `$cor7`
INNER JOIN `table$9` FOR SYSTEM_TIME AS OF `$cor7`.`timeMin` AS `t0` ON (`t0`.`id` = `$cor7`.`sensorid3`);

CREATE VIEW `table$12`
AS
SELECT *
FROM (SELECT `id`, `patientid`, `placed`, `placedTimestamp`, (ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `placedTimestamp` DESC NULLS LAST)) AS `_rownum`
FROM `sensors$1`) AS `t`
WHERE (`_rownum` = 1);

CREATE VIEW `table$13`
AS
SELECT `sensorid`, ENDOFMINUTE(`event_time`) AS `timeMin`, `temperature`, `_uuid`, `event_time`
FROM `sensorreading$1`;

CREATE VIEW `table$14`
AS
SELECT *
FROM (SELECT `id`, `patientid`, `placed`, `placedTimestamp`, (ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `placedTimestamp` DESC NULLS LAST)) AS `_rownum`
FROM `sensors$1`) AS `t`
WHERE (`_rownum` = 1);

CREATE VIEW `table$15`
AS
SELECT `sensorid`, ENDOFMINUTE(`event_time`) AS `timeMin`, `temperature`, `_uuid`, `event_time`
FROM `sensorreading$1`;

EXECUTE STATEMENT SET BEGIN
INSERT INTO `lasthour$1`
(SELECT `groupId` AS `__pk1$groupId`, `window_time` AS `__pk3$created`, MAX(`maxTemp`) AS `maxTemp`, MIN(`minTemp`) AS `minTemp`
FROM TABLE(TUMBLE((TABLE `table$5`), (DESCRIPTOR(`created`)), INTERVAL '0.001' SECOND(1))) AS `t15`
GROUP BY `groupId`, `window_start`, `window_end`, `window_time`)
;
INSERT INTO `observationgroup$2`
(SELECT *
FROM `observationgroup$1`)
;
INSERT INTO `patienthourly$1`
(SELECT `patientid`, `window_time` AS `timeHour`, AVG(`smoothTemp`) AS `avgTemp`, MAX(`smoothTemp`) AS `maxTemp`, MIN(`smoothTemp`) AS `minTemp`
FROM TABLE(TUMBLE((TABLE `table$8`), (DESCRIPTOR(`timeMin`)), INTERVAL '3600' SECOND(7), INTERVAL '0' SECOND(1))) AS `t7`
GROUP BY `patientid`, `window_start`, `window_end`, `window_time`)
;
INSERT INTO `patientlasthour$1`
(SELECT `patientid`, AVG(`smoothTemp`) AS `avgTemp`, MAX(`smoothTemp`) AS `maxTemp`, MIN(`smoothTemp`) AS `minTemp`, `window_time` AS `_timeMin`
FROM TABLE(HOP((TABLE `table$11`), (DESCRIPTOR(`timeMin`)), INTERVAL '72' SECOND(5), INTERVAL '3600' SECOND(7))) AS `t6`
GROUP BY `patientid`, `window_start`, `window_end`, `window_time`)
;
INSERT INTO `tempalert$1$1`
(SELECT `t0`.`patientid`, `$cor8`.`sensorid`, `$cor8`.`smoothTemp`, `$cor8`.`timeMin`
FROM (SELECT `sensorid`, `timeMin`, `smoothTemp`, `sensorid` AS `sensorid3`
FROM (SELECT `sensorid`, `window_time` AS `timeMin`, AVG(`temperature`) AS `smoothTemp`
FROM TABLE(TUMBLE((TABLE `table$13`), (DESCRIPTOR(`event_time`)), INTERVAL '60' SECOND(5), INTERVAL '0' SECOND(1))) AS `t2`
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`) AS `t4`
WHERE ((`smoothTemp` < 95) OR (`smoothTemp` > 102))) AS `$cor8`
INNER JOIN `table$12` FOR SYSTEM_TIME AS OF `$cor8`.`timeMin` AS `t0` ON (`t0`.`id` = `$cor8`.`sensorid3`))
;
INSERT INTO `tempalert$1$2`
(SELECT `t0`.`patientid`, `$cor9`.`sensorid`, `$cor9`.`smoothTemp`, `$cor9`.`timeMin`
FROM (SELECT `sensorid`, `timeMin`, `smoothTemp`, `sensorid` AS `sensorid3`
FROM (SELECT `sensorid`, `window_time` AS `timeMin`, AVG(`temperature`) AS `smoothTemp`
FROM TABLE(TUMBLE((TABLE `table$15`), (DESCRIPTOR(`event_time`)), INTERVAL '60' SECOND(5), INTERVAL '0' SECOND(1))) AS `t2`
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`) AS `t4`
WHERE ((`smoothTemp` < 95) OR (`smoothTemp` > 102))) AS `$cor9`
INNER JOIN `table$14` FOR SYSTEM_TIME AS OF `$cor9`.`timeMin` AS `t0` ON (`t0`.`id` = `$cor9`.`sensorid3`))
;
END;
