>>>pipeline_explain.txt
=== HighTemp
ID:     hightemp$1
Type:   stream
Stage:  streams
Inputs: secreading$1, sensors$3
Primary Key: sensorid, timeSec
Timestamp  : timeSec
Schema:
 - machineid: BIGINT NOT NULL
 - sensorid: BIGINT NOT NULL
 - temp: DOUBLE NOT NULL
 - timeSec: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalProject(machineid=[$5], sensorid=[$0], temp=[$2], timeSec=[$1])
  LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
    LogicalProject(sensorid=[$0], timeSec=[$1], temp=[$2], sensorid3=[$0])
      LogicalFilter(condition=[>($2, 100)])
        LogicalTableScan(table=[[secreading$1]])
    LogicalFilter(condition=[=($3, 1)]) hints[DedupHint]
      LogicalProject(id=[$0], machineid=[$1], placed=[$2], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $2 DESC NULLS LAST)])
        LogicalTableScan(table=[[sensors$3]])

=== print.tempWarning.tempWarning
ID:     hightemp$1$1
Type:   export
Stage:  streams
Inputs: hightemp$1

=== lastHour
ID:     lasthour$1
Type:   state
Stage:  streams
Inputs: secreading$1, sensors$3
Primary Key: __pk1$id
Timestamp  : _timeSec
Schema:
 - __pk1$id: BIGINT NOT NULL
 - maxTemp: DOUBLE NOT NULL
 - avgTemp: DOUBLE NOT NULL
 - _timeSec: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=__pk1$id limit=1 sort=#3: _timeSec TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalProject(__pk1$id=[$1], maxTemp=[$2], avgTemp=[$3], _timeSec=[$0])
  LogicalAggregate(group=[{1, 4}], maxTemp=[MAX($2)], avgTemp=[AVG($2)]) hints[SlidingAggregationHint options:[1, 3600000, 72000]]
    LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
      LogicalProject(sensorid=[$0], timeSec=[$1], temp=[$2], sensorid3=[$0])
        LogicalTableScan(table=[[secreading$1]])
      LogicalFilter(condition=[=($3, 1)]) hints[DedupHint]
        LogicalProject(id=[$0], machineid=[$1], placed=[$2], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $2 DESC NULLS LAST)])
          LogicalTableScan(table=[[sensors$3]])

=== Machine
ID:     machine$1
Type:   state
Stage:  streams
Inputs: secreading$1, sensors$3
Primary Key: machineid
Timestamp  : _timeSec
Schema:
 - machineid: BIGINT NOT NULL
 - maxTemp: DOUBLE NOT NULL
 - avgTemp: DOUBLE NOT NULL
 - _timeSec: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=machineid limit=1 sort=#3: _timeSec TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalProject(machineid=[$1], maxTemp=[$2], avgTemp=[$3], _timeSec=[$0])
  LogicalAggregate(group=[{1, 5}], maxTemp=[MAX($2)], avgTemp=[AVG($2)]) hints[SlidingAggregationHint options:[1, 3600000, 72000]]
    LogicalJoin(condition=[=($4, $3)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
      LogicalProject(sensorid=[$0], timeSec=[$1], temp=[$2], sensorid3=[$0])
        LogicalTableScan(table=[[secreading$1]])
      LogicalFilter(condition=[=($3, 1)]) hints[DedupHint]
        LogicalProject(id=[$0], machineid=[$1], placed=[$2], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $2 DESC NULLS LAST)])
          LogicalTableScan(table=[[sensors$3]])

=== SecReading
ID:     secreading$1
Type:   stream
Stage:  streams
Inputs: sensorreading$2
Primary Key: sensorid, timeSec
Timestamp  : timeSec
Schema:
 - sensorid: BIGINT NOT NULL
 - timeSec: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - temp: DOUBLE NOT NULL
Plan:
LogicalAggregate(group=[{0, 1}], temp=[AVG($2)]) hints[TumbleAggregationHint options:[1, FUNCTION, 3, 1000, 0]]
  LogicalProject(sensorid=[$0], timeSec=[endOfSecond($1)], temperature=[$2], time=[$1])
    LogicalTableScan(table=[[sensorreading$2]])

=== SensorReading
ID:     sensorreading$2
Type:   stream
Stage:  streams
Primary Key: sensorid, time
Timestamp  : time
Schema:
 - sensorid: BIGINT NOT NULL
 - time: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - temperature: DOUBLE NOT NULL
 - humidity: DOUBLE NOT NULL
Plan:
LogicalTableScan(table=[[sensorreading$1]], hints=[[[WatermarkHint inheritPath:[] options:[1]]]]) hints[WatermarkHint options:[1]]

=== Sensors
ID:     sensors$2
Type:   stream
Stage:  streams
Primary Key: id, placed
Timestamp  : placed
Schema:
 - id: BIGINT NOT NULL
 - machineid: BIGINT NOT NULL
 - placed: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalTableScan(table=[[sensors$1]], hints=[[[WatermarkHint inheritPath:[] options:[2]]]]) hints[WatermarkHint options:[2]]

=== Sensors
ID:     sensors$3
Type:   state
Stage:  streams
Inputs: sensors$2
Primary Key: id
Timestamp  : placed
Schema:
 - id: BIGINT NOT NULL
 - machineid: BIGINT NOT NULL
 - placed: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=id limit=1 sort=#2: placed TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalTableScan(table=[[sensors$2]])

>>>schema.graphqls
"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

type HighTemp {
  machineid: Float!
  sensorid: Float!
  temp: Float!
  timeSec: DateTime!
}

type Machine {
  machineid: Float!
  maxTemp: Float!
  avgTemp: Float!
  sensors(limit: Int = 10, offset: Int = 0): [Sensors!]
}

type Query {
  HighTemp(sensorid: Float, timeSec: DateTime, limit: Int = 10, offset: Int = 0): [HighTemp!]
  Machine(machineid: Float, limit: Int = 10, offset: Int = 0): [Machine!]
  SecReading(sensorid: Float, timeSec: DateTime, limit: Int = 10, offset: Int = 0): [SecReading!]
  SensorReading(sensorid: Float, time: DateTime, limit: Int = 10, offset: Int = 0): [SensorReading!]
  Sensors(id: Float, limit: Int = 10, offset: Int = 0): [Sensors!]
}

type SecReading {
  sensorid: Float!
  timeSec: DateTime!
  temp: Float!
}

type SensorReading {
  sensorid: Float!
  time: DateTime!
  temperature: Float!
  humidity: Float!
}

type Sensors {
  id: Float!
  machineid: Float!
  placed: DateTime!
  lastHour: lastHour
  readings(limit: Int = 10, offset: Int = 0): [SecReading!]
}

type lastHour {
  maxTemp: Float!
  avgTemp: Float!
  parent: Sensors!
}

