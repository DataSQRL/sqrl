>>>pipeline_explain.txt
=== HighTempAlert
ID:     default_catalog.default_database.HighTempAlert
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Primary Key: -
Timestamp  : event_time
Schema:
 - sensorid: INTEGER NOT NULL
 - temperature: FLOAT NOT NULL
 - event_time: TIMESTAMP_LTZ(3) *ROWTIME*
Plan:
LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
  LogicalFilter(condition=[>($1, 50)])
    LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW HighTempAlert AS  SELECT * FROM SensorReading WHERE temperature > 50;

=== SensorAnalysis
ID:     default_catalog.default_database.SensorAnalysis
Type:   state
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Annotations:
 - sort: [0 DESC-nulls-last]
Primary Key: sensorid
Timestamp  : -
Schema:
 - sensorid: INTEGER NOT NULL
 - avg_temperatures: FLOAT NOT NULL
 - max_temperature: FLOAT NOT NULL
Plan:
LogicalAggregate(group=[{0}], avg_temperatures=[AVG($1)], max_temperature=[MAX($1)])
  LogicalProject(sensorid=[$0], temperature=[$1])
    LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW SensorAnalysis AS  SELECT sensorid, AVG(temperature) AS avg_temperatures,
                           MAX(temperature) AS max_temperature
                    FROM SensorReading GROUP BY sensorid ORDER BY sensorid DESC;

=== SensorAnalysisById
ID:     default_catalog.default_database.SensorAnalysisById(sensorid)
Type:   query
Stage:  postgres
Inputs: default_catalog.default_database.SensorAnalysis
Annotations:
 - parameters: sensorid
Plan:
LogicalProject(sensorid=[$0], avg_temperatures=[$1], max_temperature=[$2])
  LogicalFilter(condition=[=($0, ?0)])
    LogicalTableScan(table=[[default_catalog, default_database, SensorAnalysis]])
SQL: CREATE VIEW SensorAnalysisById AS  SELECT * FROM SensorAnalysis WHERE sensorid = ?        ;

=== SensorMaxTempLastMin
ID:     default_catalog.default_database.SensorMaxTempLastMin
Type:   state
Stage:  flink
Inputs: default_catalog.default_database._SensorMaxTempLastMinWindow
Annotations:
 - mostRecentDistinct: true
Primary Key: sensorid
Timestamp  : endOfMin
Schema:
 - sensorid: INTEGER NOT NULL
 - endOfMin: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avg_temperature: FLOAT NOT NULL
Plan:
LogicalProject(sensorid=[$0], endOfMin=[$1], avg_temperature=[$2])
  LogicalFilter(condition=[=($3, 1)])
    LogicalProject(sensorid=[$0], endOfMin=[$1], avg_temperature=[$2], __sqrlinternal_rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $1 DESC NULLS LAST)])
      LogicalTableScan(table=[[default_catalog, default_database, _SensorMaxTempLastMinWindow]])
SQL: CREATE VIEW `SensorMaxTempLastMin`
AS
SELECT `sensorid`, `endOfMin`, `avg_temperature`
FROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1
=== SensorReading
ID:     default_catalog.default_database.SensorReading
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading__def
Primary Key: -
Timestamp  : event_time
Schema:
 - sensorid: INTEGER NOT NULL
 - temperature: FLOAT NOT NULL
 - event_time: TIMESTAMP_LTZ(3) *ROWTIME*
Plan:
LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
  LogicalWatermarkAssigner(rowtime=[event_time], watermark=[-($2, 0:INTERVAL SECOND)])
    LogicalProject(sensorid=[$0], temperature=[$1], event_time=[CAST($2):TIMESTAMP_LTZ(3) *ROWTIME*])
      LogicalTableScan(table=[[default_catalog, default_database, SensorReading__def, metadata=[timestamp]]])
SQL: CREATE VIEW `SensorReading`
AS
SELECT *
FROM `default_catalog`.`default_database`.`SensorReading__def`
=== _SensorMaxTempLastMinWindow
ID:     default_catalog.default_database._SensorMaxTempLastMinWindow
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Annotations:
 - features: STREAM_WINDOW_AGGREGATION (feature)
Primary Key: -
Timestamp  : endOfMin
Schema:
 - sensorid: INTEGER NOT NULL
 - endOfMin: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avg_temperature: FLOAT NOT NULL
Plan:
LogicalProject(sensorid=[$0], endOfMin=[$3], avg_temperature=[$4])
  LogicalAggregate(group=[{0, 1, 2, 3}], avg_temperature=[AVG($4)])
    LogicalProject(sensorid=[$0], window_start=[$3], window_end=[$4], endOfMin=[$5], temperature=[$1])
      LogicalTableFunctionScan(invocation=[HOP(DESCRIPTOR($2), 10000:INTERVAL SECOND, 60000:INTERVAL MINUTE)], rowType=[RecordType(INTEGER sensorid, FLOAT temperature, TIMESTAMP_LTZ(3) *ROWTIME* event_time, TIMESTAMP(3) window_start, TIMESTAMP(3) window_end, TIMESTAMP_LTZ(3) *ROWTIME* window_time)])
        LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
          LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW _SensorMaxTempLastMinWindow AS  SELECT sensorid, window_time as endOfMin,
                                      AVG(temperature) AS avg_temperature
                     FROM TABLE(HOP(TABLE SensorReading, DESCRIPTOR(event_time), INTERVAL '10' SECONDS, INTERVAL '1' MINUTES))
                     GROUP BY sensorid, window_start, window_end, window_time;

>>>flink-compiled-plan.json
{
  "flinkVersion" : "1.19",
  "nodes" : [ {
    "id" : 1,
    "type" : "stream-exec-table-source-scan_1",
    "scanTableSource" : {
      "table" : {
        "identifier" : "`default_catalog`.`default_database`.`SensorReading__def`",
        "resolvedTable" : {
          "schema" : {
            "columns" : [ {
              "name" : "sensorid",
              "dataType" : "INT NOT NULL"
            }, {
              "name" : "temperature",
              "dataType" : "FLOAT NOT NULL"
            }, {
              "name" : "event_time",
              "kind" : "METADATA",
              "dataType" : {
                "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
                "precision" : 3,
                "kind" : "ROWTIME"
              },
              "metadataKey" : "timestamp",
              "isVirtual" : false
            } ],
            "watermarkSpecs" : [ {
              "rowtimeAttribute" : "event_time",
              "expression" : {
                "rexNode" : {
                  "kind" : "CALL",
                  "syntax" : "BINARY",
                  "internalName" : "$-$1",
                  "operands" : [ {
                    "kind" : "INPUT_REF",
                    "inputIndex" : 2,
                    "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
                  }, {
                    "kind" : "LITERAL",
                    "value" : "0",
                    "type" : "INTERVAL SECOND(6) NOT NULL"
                  } ],
                  "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
                },
                "serializableString" : "`event_time` - INTERVAL '0.0' SECOND"
              }
            } ]
          },
          "partitionKeys" : [ ],
          "options" : {
            "connector" : "kafka",
            "format" : "flexible-json",
            "properties.auto.offset.reset" : "earliest",
            "properties.bootstrap.servers" : "${PROPERTIES_BOOTSTRAP_SERVERS}",
            "properties.group.id" : "${PROPERTIES_GROUP_ID}",
            "scan.startup.mode" : "group-offsets",
            "topic" : "SensorReading__def"
          }
        }
      },
      "abilities" : [ {
        "type" : "ReadingMetadata",
        "metadataKeys" : [ "timestamp" ],
        "producedType" : "ROW<`sensorid` INT NOT NULL, `temperature` FLOAT NOT NULL, `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL> NOT NULL"
      }, {
        "type" : "WatermarkPushDown",
        "watermarkExpr" : {
          "kind" : "CALL",
          "syntax" : "BINARY",
          "internalName" : "$-$1",
          "operands" : [ {
            "kind" : "CALL",
            "syntax" : "SPECIAL",
            "internalName" : "$CAST$1",
            "operands" : [ {
              "kind" : "INPUT_REF",
              "inputIndex" : 2,
              "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
            } ],
            "type" : {
              "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
              "precision" : 3,
              "kind" : "ROWTIME"
            }
          }, {
            "kind" : "LITERAL",
            "value" : "0",
            "type" : "INTERVAL SECOND(6) NOT NULL"
          } ],
          "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
        },
        "idleTimeoutMillis" : -1,
        "producedType" : "ROW<`sensorid` INT NOT NULL, `temperature` FLOAT NOT NULL, `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL> NOT NULL",
        "watermarkParams" : {
          "emitStrategy" : "ON_PERIODIC",
          "alignGroupName" : null,
          "alignMaxDrift" : "PT0S",
          "alignUpdateInterval" : "PT1S",
          "sourceIdleTimeout" : -1
        }
      } ]
    },
    "outputType" : "ROW<`sensorid` INT NOT NULL, `temperature` FLOAT NOT NULL, `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL>",
    "description" : "TableSourceScan(table=[[default_catalog, default_database, SensorReading__def, metadata=[timestamp], watermark=[-(CAST(event_time AS TIMESTAMP_LTZ(3) *ROWTIME*), 0:INTERVAL SECOND)], watermarkEmitStrategy=[on-periodic]]], fields=[sensorid, temperature, event_time])",
    "inputProperties" : [ ]
  }, {
    "id" : 2,
    "type" : "stream-exec-calc_1",
    "projection" : [ {
      "kind" : "INPUT_REF",
      "inputIndex" : 0,
      "type" : "INT NOT NULL"
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 1,
      "type" : "FLOAT NOT NULL"
    }, {
      "kind" : "CALL",
      "syntax" : "SPECIAL",
      "internalName" : "$REINTERPRET$1",
      "operands" : [ {
        "kind" : "CALL",
        "syntax" : "SPECIAL",
        "internalName" : "$CAST$1",
        "operands" : [ {
          "kind" : "INPUT_REF",
          "inputIndex" : 2,
          "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
        } ],
        "type" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ],
      "type" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "precision" : 3,
        "kind" : "ROWTIME"
      }
    } ],
    "condition" : {
      "kind" : "CALL",
      "syntax" : "BINARY",
      "internalName" : "$>$1",
      "operands" : [ {
        "kind" : "INPUT_REF",
        "inputIndex" : 1,
        "type" : "FLOAT NOT NULL"
      }, {
        "kind" : "LITERAL",
        "value" : 50,
        "type" : "INT NOT NULL"
      } ],
      "type" : "BOOLEAN NOT NULL"
    },
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ]
    },
    "description" : "Calc(select=[sensorid, temperature, Reinterpret(CAST(event_time AS TIMESTAMP_LTZ(3) *ROWTIME*)) AS event_time], where=[(temperature > 50)])"
  }, {
    "id" : 3,
    "type" : "stream-exec-sink_1",
    "configuration" : {
      "table.exec.sink.keyed-shuffle" : "AUTO",
      "table.exec.sink.not-null-enforcer" : "ERROR",
      "table.exec.sink.rowtime-inserter" : "ENABLED",
      "table.exec.sink.type-length-enforcer" : "IGNORE",
      "table.exec.sink.upsert-materialize" : "AUTO"
    },
    "dynamicTableSink" : {
      "table" : {
        "identifier" : "`default_catalog`.`default_database`.`HighTempAlert_1`",
        "resolvedTable" : {
          "schema" : {
            "columns" : [ {
              "name" : "sensorid",
              "dataType" : "INT NOT NULL"
            }, {
              "name" : "temperature",
              "dataType" : "FLOAT NOT NULL"
            }, {
              "name" : "event_time",
              "dataType" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
            } ],
            "watermarkSpecs" : [ ]
          },
          "partitionKeys" : [ ],
          "options" : {
            "connector" : "kafka",
            "format" : "flexible-json",
            "properties.auto.offset.reset" : "earliest",
            "properties.bootstrap.servers" : "${PROPERTIES_BOOTSTRAP_SERVERS}",
            "properties.group.id" : "${PROPERTIES_GROUP_ID}",
            "scan.startup.mode" : "group-offsets",
            "topic" : "HighTempAlert_1"
          }
        }
      }
    },
    "inputChangelogMode" : [ "INSERT" ],
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ]
    },
    "description" : "Sink(table=[default_catalog.default_database.HighTempAlert_1], fields=[sensorid, temperature, event_time])"
  }, {
    "id" : 4,
    "type" : "stream-exec-calc_1",
    "projection" : [ {
      "kind" : "INPUT_REF",
      "inputIndex" : 0,
      "type" : "INT NOT NULL"
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 1,
      "type" : "FLOAT NOT NULL"
    } ],
    "condition" : null,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `temperature` FLOAT NOT NULL>",
    "description" : "Calc(select=[sensorid, temperature])"
  }, {
    "id" : 5,
    "type" : "stream-exec-exchange_1",
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "HASH",
        "keys" : [ 0 ]
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `temperature` FLOAT NOT NULL>",
    "description" : "Exchange(distribution=[hash[sensorid]])"
  }, {
    "id" : 6,
    "type" : "stream-exec-group-aggregate_1",
    "configuration" : {
      "table.exec.mini-batch.enabled" : "false",
      "table.exec.mini-batch.size" : "-1"
    },
    "grouping" : [ 0 ],
    "aggCalls" : [ {
      "name" : "avg_temperatures",
      "internalName" : "$AVG$1",
      "argList" : [ 1 ],
      "filterArg" : -1,
      "distinct" : false,
      "approximate" : false,
      "ignoreNulls" : false,
      "type" : "FLOAT NOT NULL"
    }, {
      "name" : "max_temperature",
      "internalName" : "$MAX$1",
      "argList" : [ 1 ],
      "filterArg" : -1,
      "distinct" : false,
      "approximate" : false,
      "ignoreNulls" : false,
      "type" : "FLOAT NOT NULL"
    } ],
    "aggCallNeedRetractions" : [ false, false ],
    "generateUpdateBefore" : false,
    "needRetraction" : false,
    "state" : [ {
      "index" : 0,
      "ttl" : "0 ms",
      "name" : "groupAggregateState"
    } ],
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `avg_temperatures` FLOAT NOT NULL, `max_temperature` FLOAT NOT NULL>",
    "description" : "GroupAggregate(groupBy=[sensorid], select=[sensorid, AVG(temperature) AS avg_temperatures, MAX(temperature) AS max_temperature])"
  }, {
    "id" : 7,
    "type" : "stream-exec-sink_1",
    "configuration" : {
      "table.exec.sink.keyed-shuffle" : "AUTO",
      "table.exec.sink.not-null-enforcer" : "ERROR",
      "table.exec.sink.rowtime-inserter" : "ENABLED",
      "table.exec.sink.type-length-enforcer" : "IGNORE",
      "table.exec.sink.upsert-materialize" : "AUTO"
    },
    "dynamicTableSink" : {
      "table" : {
        "identifier" : "`default_catalog`.`default_database`.`SensorAnalysis_2`",
        "resolvedTable" : {
          "schema" : {
            "columns" : [ {
              "name" : "sensorid",
              "dataType" : "INT NOT NULL"
            }, {
              "name" : "avg_temperatures",
              "dataType" : "FLOAT NOT NULL"
            }, {
              "name" : "max_temperature",
              "dataType" : "FLOAT NOT NULL"
            } ],
            "watermarkSpecs" : [ ],
            "primaryKey" : {
              "name" : "PK_sensorid",
              "type" : "PRIMARY_KEY",
              "columns" : [ "sensorid" ]
            }
          },
          "partitionKeys" : [ ],
          "options" : {
            "connector" : "jdbc-sqrl",
            "driver" : "org.postgresql.Driver",
            "password" : "${JDBC_PASSWORD}",
            "table-name" : "SensorAnalysis_2",
            "url" : "jdbc:postgresql://${JDBC_URL}",
            "username" : "${JDBC_USERNAME}"
          }
        }
      }
    },
    "inputChangelogMode" : [ "INSERT", "UPDATE_AFTER" ],
    "inputUpsertKey" : [ 0 ],
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `avg_temperatures` FLOAT NOT NULL, `max_temperature` FLOAT NOT NULL>",
    "description" : "Sink(table=[default_catalog.default_database.SensorAnalysis_2], fields=[sensorid, avg_temperatures, max_temperature])"
  }, {
    "id" : 8,
    "type" : "stream-exec-calc_1",
    "projection" : [ {
      "kind" : "INPUT_REF",
      "inputIndex" : 0,
      "type" : "INT NOT NULL"
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 1,
      "type" : "FLOAT NOT NULL"
    }, {
      "kind" : "CALL",
      "syntax" : "SPECIAL",
      "internalName" : "$REINTERPRET$1",
      "operands" : [ {
        "kind" : "CALL",
        "syntax" : "SPECIAL",
        "internalName" : "$CAST$1",
        "operands" : [ {
          "kind" : "INPUT_REF",
          "inputIndex" : 2,
          "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
        } ],
        "type" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ],
      "type" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "precision" : 3,
        "kind" : "ROWTIME"
      }
    } ],
    "condition" : null,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ]
    },
    "description" : "Calc(select=[sensorid, temperature, Reinterpret(CAST(event_time AS TIMESTAMP_LTZ(3) *ROWTIME*)) AS event_time])"
  }, {
    "id" : 9,
    "type" : "stream-exec-local-window-aggregate_1",
    "configuration" : {
      "table.local-time-zone" : "default"
    },
    "grouping" : [ 0 ],
    "aggCalls" : [ {
      "name" : "avg_temperature",
      "internalName" : "$AVG$1",
      "argList" : [ 1 ],
      "filterArg" : -1,
      "distinct" : false,
      "approximate" : false,
      "ignoreNulls" : false,
      "type" : "FLOAT NOT NULL"
    } ],
    "windowing" : {
      "strategy" : "TimeAttribute",
      "window" : {
        "type" : "HoppingWindow",
        "size" : "PT1M",
        "slide" : "PT10S"
      },
      "timeAttributeType" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "precision" : 3,
        "kind" : "ROWTIME"
      },
      "timeAttributeIndex" : 2,
      "isRowtime" : true
    },
    "needRetraction" : false,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `sum$0` DOUBLE, `count$1` BIGINT, `count1$2` BIGINT, `$slice_end` BIGINT>",
    "description" : "LocalWindowAggregate(groupBy=[sensorid], window=[HOP(time_col=[event_time], size=[1 min], slide=[10 s])], select=[sensorid, AVG(temperature) AS (sum$0, count$1), COUNT(*) AS count1$2, slice_end('w$) AS $slice_end])"
  }, {
    "id" : 10,
    "type" : "stream-exec-exchange_1",
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "HASH",
        "keys" : [ 0 ]
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : "ROW<`sensorid` INT NOT NULL, `sum$0` DOUBLE, `count$1` BIGINT, `count1$2` BIGINT, `$slice_end` BIGINT>",
    "description" : "Exchange(distribution=[hash[sensorid]])"
  }, {
    "id" : 11,
    "type" : "stream-exec-global-window-aggregate_1",
    "configuration" : {
      "table.local-time-zone" : "default"
    },
    "grouping" : [ 0 ],
    "aggCalls" : [ {
      "name" : "avg_temperature",
      "internalName" : "$AVG$1",
      "argList" : [ 1 ],
      "filterArg" : -1,
      "distinct" : false,
      "approximate" : false,
      "ignoreNulls" : false,
      "type" : "FLOAT NOT NULL"
    } ],
    "windowing" : {
      "strategy" : "SliceAttached",
      "window" : {
        "type" : "HoppingWindow",
        "size" : "PT1M",
        "slide" : "PT10S"
      },
      "timeAttributeType" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "precision" : 3,
        "kind" : "ROWTIME"
      },
      "sliceEnd" : 4,
      "isRowtime" : true
    },
    "namedWindowProperties" : [ {
      "name" : "window_start",
      "property" : {
        "kind" : "WindowStart",
        "reference" : {
          "name" : "w$",
          "type" : {
            "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
            "precision" : 3,
            "kind" : "ROWTIME"
          }
        }
      }
    }, {
      "name" : "window_end",
      "property" : {
        "kind" : "WindowEnd",
        "reference" : {
          "name" : "w$",
          "type" : {
            "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
            "precision" : 3,
            "kind" : "ROWTIME"
          }
        }
      }
    }, {
      "name" : "window_time",
      "property" : {
        "kind" : "Rowtime",
        "reference" : {
          "name" : "w$",
          "type" : {
            "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
            "precision" : 3,
            "kind" : "ROWTIME"
          }
        }
      }
    } ],
    "needRetraction" : false,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "localAggInputRowType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ]
    },
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "avg_temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "window_start",
        "fieldType" : "TIMESTAMP(3) NOT NULL"
      }, {
        "name" : "window_end",
        "fieldType" : "TIMESTAMP(3) NOT NULL"
      }, {
        "name" : "window_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "nullable" : false,
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ]
    },
    "description" : "GlobalWindowAggregate(groupBy=[sensorid], window=[HOP(slice_end=[$slice_end], size=[1 min], slide=[10 s])], select=[sensorid, AVG((sum$0, count$1)) AS avg_temperature, COUNT(count1$2) AS window_start, start('w$) AS window_end, end('w$) AS window_time])"
  }, {
    "id" : 12,
    "type" : "stream-exec-calc_1",
    "projection" : [ {
      "kind" : "INPUT_REF",
      "inputIndex" : 0,
      "type" : "INT NOT NULL"
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 4,
      "type" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "nullable" : false,
        "precision" : 3,
        "kind" : "ROWTIME"
      }
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 1,
      "type" : "FLOAT NOT NULL"
    } ],
    "condition" : null,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "endOfMin",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "nullable" : false,
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      }, {
        "name" : "avg_temperature",
        "fieldType" : "FLOAT NOT NULL"
      } ]
    },
    "description" : "Calc(select=[sensorid, window_time AS endOfMin, avg_temperature])"
  }, {
    "id" : 13,
    "type" : "stream-exec-sink_1",
    "configuration" : {
      "table.exec.sink.keyed-shuffle" : "AUTO",
      "table.exec.sink.not-null-enforcer" : "ERROR",
      "table.exec.sink.rowtime-inserter" : "ENABLED",
      "table.exec.sink.type-length-enforcer" : "IGNORE",
      "table.exec.sink.upsert-materialize" : "AUTO"
    },
    "dynamicTableSink" : {
      "table" : {
        "identifier" : "`default_catalog`.`default_database`.`SensorMaxTempLastMin_3`",
        "resolvedTable" : {
          "schema" : {
            "columns" : [ {
              "name" : "sensorid",
              "dataType" : "INT NOT NULL"
            }, {
              "name" : "endOfMin",
              "dataType" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
            }, {
              "name" : "avg_temperature",
              "dataType" : "FLOAT NOT NULL"
            } ],
            "watermarkSpecs" : [ ],
            "primaryKey" : {
              "name" : "PK_sensorid",
              "type" : "PRIMARY_KEY",
              "columns" : [ "sensorid" ]
            }
          },
          "partitionKeys" : [ ],
          "options" : {
            "connector" : "jdbc-sqrl",
            "driver" : "org.postgresql.Driver",
            "password" : "${JDBC_PASSWORD}",
            "table-name" : "SensorMaxTempLastMin_3",
            "url" : "jdbc:postgresql://${JDBC_URL}",
            "username" : "${JDBC_USERNAME}"
          }
        }
      }
    },
    "inputChangelogMode" : [ "INSERT" ],
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "endOfMin",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "nullable" : false,
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      }, {
        "name" : "avg_temperature",
        "fieldType" : "FLOAT NOT NULL"
      } ]
    },
    "description" : "Sink(table=[default_catalog.default_database.SensorMaxTempLastMin_3], fields=[sensorid, endOfMin, avg_temperature])"
  }, {
    "id" : 14,
    "type" : "stream-exec-calc_1",
    "projection" : [ {
      "kind" : "INPUT_REF",
      "inputIndex" : 0,
      "type" : "INT NOT NULL"
    }, {
      "kind" : "INPUT_REF",
      "inputIndex" : 1,
      "type" : "FLOAT NOT NULL"
    }, {
      "kind" : "CALL",
      "syntax" : "SPECIAL",
      "internalName" : "$REINTERPRET$1",
      "operands" : [ {
        "kind" : "CALL",
        "syntax" : "SPECIAL",
        "internalName" : "$CAST$1",
        "operands" : [ {
          "kind" : "INPUT_REF",
          "inputIndex" : 2,
          "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
        } ],
        "type" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      } ],
      "type" : {
        "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
        "precision" : 3,
        "kind" : "ROWTIME"
      }
    }, {
      "kind" : "CALL",
      "systemName" : "HASHCOLUMNS",
      "operands" : [ {
        "kind" : "INPUT_REF",
        "inputIndex" : 0,
        "type" : "INT NOT NULL"
      }, {
        "kind" : "INPUT_REF",
        "inputIndex" : 1,
        "type" : "FLOAT NOT NULL"
      }, {
        "kind" : "CALL",
        "syntax" : "SPECIAL",
        "internalName" : "$CAST$1",
        "operands" : [ {
          "kind" : "CALL",
          "syntax" : "SPECIAL",
          "internalName" : "$REINTERPRET$1",
          "operands" : [ {
            "kind" : "CALL",
            "syntax" : "SPECIAL",
            "internalName" : "$CAST$1",
            "operands" : [ {
              "kind" : "INPUT_REF",
              "inputIndex" : 2,
              "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL"
            } ],
            "type" : {
              "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
              "precision" : 3,
              "kind" : "ROWTIME"
            }
          } ],
          "type" : {
            "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
            "precision" : 3,
            "kind" : "ROWTIME"
          }
        } ],
        "type" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
      } ],
      "type" : "CHAR(32)"
    } ],
    "condition" : null,
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      }, {
        "name" : "__pk_hash",
        "fieldType" : "CHAR(32)"
      } ]
    },
    "description" : "Calc(select=[sensorid, temperature, Reinterpret(CAST(event_time AS TIMESTAMP_LTZ(3) *ROWTIME*)) AS event_time, HASHCOLUMNS(sensorid, temperature, CAST(Reinterpret(CAST(event_time AS TIMESTAMP_LTZ(3) *ROWTIME*)) AS TIMESTAMP_WITH_LOCAL_TIME_ZONE(3))) AS __pk_hash])"
  }, {
    "id" : 15,
    "type" : "stream-exec-sink_1",
    "configuration" : {
      "table.exec.sink.keyed-shuffle" : "AUTO",
      "table.exec.sink.not-null-enforcer" : "ERROR",
      "table.exec.sink.rowtime-inserter" : "ENABLED",
      "table.exec.sink.type-length-enforcer" : "IGNORE",
      "table.exec.sink.upsert-materialize" : "AUTO"
    },
    "dynamicTableSink" : {
      "table" : {
        "identifier" : "`default_catalog`.`default_database`.`SensorReading_4`",
        "resolvedTable" : {
          "schema" : {
            "columns" : [ {
              "name" : "sensorid",
              "dataType" : "INT NOT NULL"
            }, {
              "name" : "temperature",
              "dataType" : "FLOAT NOT NULL"
            }, {
              "name" : "event_time",
              "dataType" : "TIMESTAMP(3) WITH LOCAL TIME ZONE"
            }, {
              "name" : "__pk_hash",
              "dataType" : "CHAR(32) NOT NULL"
            } ],
            "watermarkSpecs" : [ ],
            "primaryKey" : {
              "name" : "PK___pk_hash",
              "type" : "PRIMARY_KEY",
              "columns" : [ "__pk_hash" ]
            }
          },
          "partitionKeys" : [ ],
          "options" : {
            "connector" : "jdbc-sqrl",
            "driver" : "org.postgresql.Driver",
            "password" : "${JDBC_PASSWORD}",
            "table-name" : "SensorReading_4",
            "url" : "jdbc:postgresql://${JDBC_URL}",
            "username" : "${JDBC_USERNAME}"
          }
        }
      }
    },
    "inputChangelogMode" : [ "INSERT" ],
    "inputProperties" : [ {
      "requiredDistribution" : {
        "type" : "UNKNOWN"
      },
      "damBehavior" : "PIPELINED",
      "priority" : 0
    } ],
    "outputType" : {
      "type" : "ROW",
      "fields" : [ {
        "name" : "sensorid",
        "fieldType" : "INT NOT NULL"
      }, {
        "name" : "temperature",
        "fieldType" : "FLOAT NOT NULL"
      }, {
        "name" : "event_time",
        "fieldType" : {
          "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
          "precision" : 3,
          "kind" : "ROWTIME"
        }
      }, {
        "name" : "__pk_hash",
        "fieldType" : "CHAR(32)"
      } ]
    },
    "description" : "Sink(table=[default_catalog.default_database.SensorReading_4], fields=[sensorid, temperature, event_time, __pk_hash])"
  } ],
  "edges" : [ {
    "source" : 1,
    "target" : 2,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 2,
    "target" : 3,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 1,
    "target" : 4,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 4,
    "target" : 5,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 5,
    "target" : 6,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 6,
    "target" : 7,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 1,
    "target" : 8,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 8,
    "target" : 9,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 9,
    "target" : 10,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 10,
    "target" : 11,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 11,
    "target" : 12,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 12,
    "target" : 13,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 1,
    "target" : 14,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  }, {
    "source" : 14,
    "target" : 15,
    "shuffle" : {
      "type" : "FORWARD"
    },
    "shuffleMode" : "PIPELINED"
  } ]
}
>>>flink-functions.sql
CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineSimilarity` AS 'com.datasqrl.vector.CosineSimilarity' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `noop` AS 'com.datasqrl.datatype.Noop' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObjectAgg` AS 'com.datasqrl.json.JsonObjectAgg' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonToString` AS 'com.datasqrl.json.JsonToString' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToString` AS 'com.datasqrl.time.TimestampToString' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExists` AS 'com.datasqrl.json.JsonExists' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObject` AS 'com.datasqrl.json.JsonObject' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArray` AS 'com.datasqrl.json.JsonArray' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonQuery` AS 'com.datasqrl.json.JsonQuery' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonConcat` AS 'com.datasqrl.json.JsonConcat' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `format` AS 'com.datasqrl.text.Format' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `atZone` AS 'com.datasqrl.time.AtZone' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExtract` AS 'com.datasqrl.json.JsonExtract' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineDistance` AS 'com.datasqrl.vector.CosineDistance' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpoch` AS 'com.datasqrl.time.TimestampToEpoch' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `epochToTimestamp` AS 'com.datasqrl.time.EpochToTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `asciiTextTestEmbed` AS 'com.datasqrl.vector.AsciiTextTestEmbed' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpochMilli` AS 'com.datasqrl.time.TimestampToEpochMilli' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `epochMilliToTimestamp` AS 'com.datasqrl.time.EpochMilliToTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArrayAgg` AS 'com.datasqrl.json.JsonArrayAgg' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `vectorToDouble` AS 'com.datasqrl.vector.VectorToDouble' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `split` AS 'com.datasqrl.text.Split' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `center` AS 'com.datasqrl.vector.Center' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `parseTimestamp` AS 'com.datasqrl.time.ParseTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `serializeToBytes` AS 'com.datasqrl.datatype.SerializeToBytes' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `toJson` AS 'com.datasqrl.json.ToJson' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `textSearch` AS 'com.datasqrl.text.TextSearch' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `hashColumns` AS 'com.datasqrl.datatype.HashColumns' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `euclideanDistance` AS 'com.datasqrl.vector.EuclideanDistance' LANGUAGE JAVA
>>>flink-sql-no-functions.sql
CREATE TABLE `SensorReading__def` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP_LTZ(3) METADATA FROM 'timestamp',
  WATERMARK FOR `event_time` AS `event_time` - INTERVAL '0.0' SECOND
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'SensorReading__def'
);
CREATE VIEW `SensorReading`
AS
SELECT *
FROM `default_catalog`.`default_database`.`SensorReading__def`;
CREATE VIEW `HighTempAlert`
AS
SELECT *
FROM `SensorReading`
WHERE `temperature` > 50;
CREATE VIEW `_SensorMaxTempLastMinWindow`
AS
SELECT `sensorid`, `window_time` AS `endOfMin`, AVG(`temperature`) AS `avg_temperature`
FROM TABLE(HOP(TABLE `SensorReading`, DESCRIPTOR(`event_time`), INTERVAL '10' SECOND, INTERVAL '1' MINUTE))
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`;
CREATE VIEW `SensorMaxTempLastMin`
AS
SELECT `sensorid`, `endOfMin`, `avg_temperature`
FROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1;
CREATE VIEW `SensorAnalysis`
AS
SELECT `sensorid`, AVG(`temperature`) AS `avg_temperatures`, MAX(`temperature`) AS `max_temperature`
FROM `SensorReading`
GROUP BY `sensorid`;
CREATE TABLE `HighTempAlert_1` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'HighTempAlert_1'
);
CREATE TABLE `SensorAnalysis_2` (
  `sensorid` INTEGER NOT NULL,
  `avg_temperatures` FLOAT NOT NULL,
  `max_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorAnalysis_2'
);
CREATE TABLE `SensorMaxTempLastMin_3` (
  `sensorid` INTEGER NOT NULL,
  `endOfMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `avg_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorMaxTempLastMin_3'
);
CREATE TABLE `SensorReading_4` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE,
  `__pk_hash` CHAR(32) CHARACTER SET `UTF-16LE`,
  PRIMARY KEY (`__pk_hash`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorReading_4'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`HighTempAlert_1`
(SELECT *
 FROM `default_catalog`.`default_database`.`HighTempAlert`)
;
INSERT INTO `default_catalog`.`default_database`.`SensorAnalysis_2`
 (SELECT *
  FROM `default_catalog`.`default_database`.`SensorAnalysis`)
 ;
 INSERT INTO `default_catalog`.`default_database`.`SensorMaxTempLastMin_3`
  (SELECT *
   FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`)
  ;
  INSERT INTO `default_catalog`.`default_database`.`SensorReading_4`
   (SELECT `sensorid`, `temperature`, `event_time`, HASHCOLUMNS(`sensorid`, `temperature`, `event_time`) AS `__pk_hash`
    FROM `default_catalog`.`default_database`.`SensorReading`)
   ;
   END
>>>flink-sql.sql
CREATE SYSTEM FUNCTION IF NOT EXISTS `toJson` AS 'com.datasqrl.json.ToJson' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonToString` AS 'com.datasqrl.json.JsonToString' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObject` AS 'com.datasqrl.json.JsonObject' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArray` AS 'com.datasqrl.json.JsonArray' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExtract` AS 'com.datasqrl.json.JsonExtract' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonQuery` AS 'com.datasqrl.json.JsonQuery' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExists` AS 'com.datasqrl.json.JsonExists' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonConcat` AS 'com.datasqrl.json.JsonConcat' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArrayAgg` AS 'com.datasqrl.json.JsonArrayAgg' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObjectAgg` AS 'com.datasqrl.json.JsonObjectAgg' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `split` AS 'com.datasqrl.text.Split' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `textSearch` AS 'com.datasqrl.text.TextSearch' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `format` AS 'com.datasqrl.text.Format' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `serializeToBytes` AS 'com.datasqrl.datatype.SerializeToBytes' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `noop` AS 'com.datasqrl.datatype.Noop' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `hashColumns` AS 'com.datasqrl.datatype.HashColumns' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `epochToTimestamp` AS 'com.datasqrl.time.EpochToTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `epochMilliToTimestamp` AS 'com.datasqrl.time.EpochMilliToTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpoch` AS 'com.datasqrl.time.TimestampToEpoch' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpochMilli` AS 'com.datasqrl.time.TimestampToEpochMilli' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `parseTimestamp` AS 'com.datasqrl.time.ParseTimestamp' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToString` AS 'com.datasqrl.time.TimestampToString' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `atZone` AS 'com.datasqrl.time.AtZone' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineSimilarity` AS 'com.datasqrl.vector.CosineSimilarity' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineDistance` AS 'com.datasqrl.vector.CosineDistance' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `euclideanDistance` AS 'com.datasqrl.vector.EuclideanDistance' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `vectorToDouble` AS 'com.datasqrl.vector.VectorToDouble' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `asciiTextTestEmbed` AS 'com.datasqrl.vector.AsciiTextTestEmbed' LANGUAGE JAVA;
CREATE SYSTEM FUNCTION IF NOT EXISTS `center` AS 'com.datasqrl.vector.Center' LANGUAGE JAVA;
CREATE TABLE `SensorReading__def` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP_LTZ(3) METADATA FROM 'timestamp',
  WATERMARK FOR `event_time` AS `event_time` - INTERVAL '0.0' SECOND
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'SensorReading__def'
);
CREATE VIEW `SensorReading`
AS
SELECT *
FROM `default_catalog`.`default_database`.`SensorReading__def`;
CREATE VIEW `HighTempAlert`
AS
SELECT *
FROM `SensorReading`
WHERE `temperature` > 50;
CREATE VIEW `_SensorMaxTempLastMinWindow`
AS
SELECT `sensorid`, `window_time` AS `endOfMin`, AVG(`temperature`) AS `avg_temperature`
FROM TABLE(HOP(TABLE `SensorReading`, DESCRIPTOR(`event_time`), INTERVAL '10' SECOND, INTERVAL '1' MINUTE))
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`;
CREATE VIEW `SensorMaxTempLastMin`
AS
SELECT `sensorid`, `endOfMin`, `avg_temperature`
FROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1;
CREATE VIEW `SensorAnalysis`
AS
SELECT `sensorid`, AVG(`temperature`) AS `avg_temperatures`, MAX(`temperature`) AS `max_temperature`
FROM `SensorReading`
GROUP BY `sensorid`;
CREATE TABLE `HighTempAlert_1` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'HighTempAlert_1'
);
CREATE TABLE `SensorAnalysis_2` (
  `sensorid` INTEGER NOT NULL,
  `avg_temperatures` FLOAT NOT NULL,
  `max_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorAnalysis_2'
);
CREATE TABLE `SensorMaxTempLastMin_3` (
  `sensorid` INTEGER NOT NULL,
  `endOfMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `avg_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorMaxTempLastMin_3'
);
CREATE TABLE `SensorReading_4` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE,
  `__pk_hash` CHAR(32) CHARACTER SET `UTF-16LE`,
  PRIMARY KEY (`__pk_hash`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_URL}',
  'table-name' = 'SensorReading_4'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`HighTempAlert_1`
(SELECT *
 FROM `default_catalog`.`default_database`.`HighTempAlert`)
;
INSERT INTO `default_catalog`.`default_database`.`SensorAnalysis_2`
 (SELECT *
  FROM `default_catalog`.`default_database`.`SensorAnalysis`)
 ;
 INSERT INTO `default_catalog`.`default_database`.`SensorMaxTempLastMin_3`
  (SELECT *
   FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`)
  ;
  INSERT INTO `default_catalog`.`default_database`.`SensorReading_4`
   (SELECT `sensorid`, `temperature`, `event_time`, HASHCOLUMNS(`sensorid`, `temperature`, `event_time`) AS `__pk_hash`
    FROM `default_catalog`.`default_database`.`SensorReading`)
   ;
   END
>>>flink.json
{
  "flinkSql" : [
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `toJson` AS 'com.datasqrl.json.ToJson' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonToString` AS 'com.datasqrl.json.JsonToString' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObject` AS 'com.datasqrl.json.JsonObject' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArray` AS 'com.datasqrl.json.JsonArray' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExtract` AS 'com.datasqrl.json.JsonExtract' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonQuery` AS 'com.datasqrl.json.JsonQuery' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExists` AS 'com.datasqrl.json.JsonExists' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonConcat` AS 'com.datasqrl.json.JsonConcat' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArrayAgg` AS 'com.datasqrl.json.JsonArrayAgg' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObjectAgg` AS 'com.datasqrl.json.JsonObjectAgg' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `split` AS 'com.datasqrl.text.Split' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `textSearch` AS 'com.datasqrl.text.TextSearch' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `format` AS 'com.datasqrl.text.Format' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `serializeToBytes` AS 'com.datasqrl.datatype.SerializeToBytes' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `noop` AS 'com.datasqrl.datatype.Noop' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `hashColumns` AS 'com.datasqrl.datatype.HashColumns' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `epochToTimestamp` AS 'com.datasqrl.time.EpochToTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `epochMilliToTimestamp` AS 'com.datasqrl.time.EpochMilliToTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpoch` AS 'com.datasqrl.time.TimestampToEpoch' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpochMilli` AS 'com.datasqrl.time.TimestampToEpochMilli' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `parseTimestamp` AS 'com.datasqrl.time.ParseTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToString` AS 'com.datasqrl.time.TimestampToString' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `atZone` AS 'com.datasqrl.time.AtZone' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineSimilarity` AS 'com.datasqrl.vector.CosineSimilarity' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineDistance` AS 'com.datasqrl.vector.CosineDistance' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `euclideanDistance` AS 'com.datasqrl.vector.EuclideanDistance' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `vectorToDouble` AS 'com.datasqrl.vector.VectorToDouble' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `asciiTextTestEmbed` AS 'com.datasqrl.vector.AsciiTextTestEmbed' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `center` AS 'com.datasqrl.vector.Center' LANGUAGE JAVA",
    "CREATE TABLE `SensorReading__def` (\n  `sensorid` INTEGER NOT NULL,\n  `temperature` FLOAT NOT NULL,\n  `event_time` TIMESTAMP_LTZ(3) METADATA FROM 'timestamp',\n  WATERMARK FOR `event_time` AS `event_time` - INTERVAL '0.0' SECOND\n) WITH (\n  'connector' = 'kafka',\n  'format' = 'flexible-json',\n  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',\n  'properties.group.id' = '${PROPERTIES_GROUP_ID}',\n  'scan.startup.mode' = 'group-offsets',\n  'properties.auto.offset.reset' = 'earliest',\n  'topic' = 'SensorReading__def'\n)",
    "CREATE VIEW `SensorReading`\nAS\nSELECT *\nFROM `default_catalog`.`default_database`.`SensorReading__def`",
    "CREATE VIEW `HighTempAlert`\nAS\nSELECT *\nFROM `SensorReading`\nWHERE `temperature` > 50",
    "CREATE VIEW `_SensorMaxTempLastMinWindow`\nAS\nSELECT `sensorid`, `window_time` AS `endOfMin`, AVG(`temperature`) AS `avg_temperature`\nFROM TABLE(HOP(TABLE `SensorReading`, DESCRIPTOR(`event_time`), INTERVAL '10' SECOND, INTERVAL '1' MINUTE))\nGROUP BY `sensorid`, `window_start`, `window_end`, `window_time`",
    "CREATE VIEW `SensorMaxTempLastMin`\nAS\nSELECT `sensorid`, `endOfMin`, `avg_temperature`\nFROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`\n  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`\nWHERE `__sqrlinternal_rownum` = 1",
    "CREATE VIEW `SensorAnalysis`\nAS\nSELECT `sensorid`, AVG(`temperature`) AS `avg_temperatures`, MAX(`temperature`) AS `max_temperature`\nFROM `SensorReading`\nGROUP BY `sensorid`",
    "CREATE TABLE `HighTempAlert_1` (\n  `sensorid` INTEGER NOT NULL,\n  `temperature` FLOAT NOT NULL,\n  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE\n) WITH (\n  'connector' = 'kafka',\n  'format' = 'flexible-json',\n  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',\n  'properties.group.id' = '${PROPERTIES_GROUP_ID}',\n  'scan.startup.mode' = 'group-offsets',\n  'properties.auto.offset.reset' = 'earliest',\n  'topic' = 'HighTempAlert_1'\n)",
    "CREATE TABLE `SensorAnalysis_2` (\n  `sensorid` INTEGER NOT NULL,\n  `avg_temperatures` FLOAT NOT NULL,\n  `max_temperature` FLOAT NOT NULL,\n  PRIMARY KEY (`sensorid`) NOT ENFORCED\n) WITH (\n  'connector' = 'jdbc-sqrl',\n  'password' = '${JDBC_PASSWORD}',\n  'driver' = 'org.postgresql.Driver',\n  'username' = '${JDBC_USERNAME}',\n  'url' = 'jdbc:postgresql://${JDBC_URL}',\n  'table-name' = 'SensorAnalysis_2'\n)",
    "CREATE TABLE `SensorMaxTempLastMin_3` (\n  `sensorid` INTEGER NOT NULL,\n  `endOfMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,\n  `avg_temperature` FLOAT NOT NULL,\n  PRIMARY KEY (`sensorid`) NOT ENFORCED\n) WITH (\n  'connector' = 'jdbc-sqrl',\n  'password' = '${JDBC_PASSWORD}',\n  'driver' = 'org.postgresql.Driver',\n  'username' = '${JDBC_USERNAME}',\n  'url' = 'jdbc:postgresql://${JDBC_URL}',\n  'table-name' = 'SensorMaxTempLastMin_3'\n)",
    "CREATE TABLE `SensorReading_4` (\n  `sensorid` INTEGER NOT NULL,\n  `temperature` FLOAT NOT NULL,\n  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE,\n  `__pk_hash` CHAR(32) CHARACTER SET `UTF-16LE`,\n  PRIMARY KEY (`__pk_hash`) NOT ENFORCED\n) WITH (\n  'connector' = 'jdbc-sqrl',\n  'password' = '${JDBC_PASSWORD}',\n  'driver' = 'org.postgresql.Driver',\n  'username' = '${JDBC_USERNAME}',\n  'url' = 'jdbc:postgresql://${JDBC_URL}',\n  'table-name' = 'SensorReading_4'\n)",
    "EXECUTE STATEMENT SET BEGIN\nINSERT INTO `default_catalog`.`default_database`.`HighTempAlert_1`\n(SELECT *\n FROM `default_catalog`.`default_database`.`HighTempAlert`)\n;\nINSERT INTO `default_catalog`.`default_database`.`SensorAnalysis_2`\n (SELECT *\n  FROM `default_catalog`.`default_database`.`SensorAnalysis`)\n ;\n INSERT INTO `default_catalog`.`default_database`.`SensorMaxTempLastMin_3`\n  (SELECT *\n   FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`)\n  ;\n  INSERT INTO `default_catalog`.`default_database`.`SensorReading_4`\n   (SELECT `sensorid`, `temperature`, `event_time`, HASHCOLUMNS(`sensorid`, `temperature`, `event_time`) AS `__pk_hash`\n    FROM `default_catalog`.`default_database`.`SensorReading`)\n   ;\n   END"
  ],
  "connectors" : [
    "jdbc-sqrl",
    "kafka"
  ],
  "formats" : [
    "flexible-json"
  ],
  "functions" : [
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineSimilarity` AS 'com.datasqrl.vector.CosineSimilarity' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `noop` AS 'com.datasqrl.datatype.Noop' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObjectAgg` AS 'com.datasqrl.json.JsonObjectAgg' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonToString` AS 'com.datasqrl.json.JsonToString' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToString` AS 'com.datasqrl.time.TimestampToString' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExists` AS 'com.datasqrl.json.JsonExists' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonObject` AS 'com.datasqrl.json.JsonObject' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArray` AS 'com.datasqrl.json.JsonArray' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonQuery` AS 'com.datasqrl.json.JsonQuery' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonConcat` AS 'com.datasqrl.json.JsonConcat' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `format` AS 'com.datasqrl.text.Format' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `atZone` AS 'com.datasqrl.time.AtZone' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonExtract` AS 'com.datasqrl.json.JsonExtract' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `cosineDistance` AS 'com.datasqrl.vector.CosineDistance' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpoch` AS 'com.datasqrl.time.TimestampToEpoch' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `epochToTimestamp` AS 'com.datasqrl.time.EpochToTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `asciiTextTestEmbed` AS 'com.datasqrl.vector.AsciiTextTestEmbed' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `timestampToEpochMilli` AS 'com.datasqrl.time.TimestampToEpochMilli' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `epochMilliToTimestamp` AS 'com.datasqrl.time.EpochMilliToTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `jsonArrayAgg` AS 'com.datasqrl.json.JsonArrayAgg' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `vectorToDouble` AS 'com.datasqrl.vector.VectorToDouble' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `split` AS 'com.datasqrl.text.Split' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `center` AS 'com.datasqrl.vector.Center' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `parseTimestamp` AS 'com.datasqrl.time.ParseTimestamp' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `serializeToBytes` AS 'com.datasqrl.datatype.SerializeToBytes' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `toJson` AS 'com.datasqrl.json.ToJson' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `textSearch` AS 'com.datasqrl.text.TextSearch' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `hashColumns` AS 'com.datasqrl.datatype.HashColumns' LANGUAGE JAVA",
    "CREATE SYSTEM FUNCTION IF NOT EXISTS `euclideanDistance` AS 'com.datasqrl.vector.EuclideanDistance' LANGUAGE JAVA"
  ]
}
>>>kafka.json
{
  "topics" : [
    {
      "name" : "HighTempAlert_1",
      "numPartitions" : 1,
      "replicationFactor" : 1,
      "replicasAssignments" : { },
      "config" : { }
    },
    {
      "name" : "SensorReading__def",
      "numPartitions" : 1,
      "replicationFactor" : 1,
      "replicasAssignments" : { },
      "config" : { }
    }
  ]
}
>>>postgres-schema.sql

CREATE TABLE IF NOT EXISTS "SensorAnalysis_2" ("sensorid" INTEGER NOT NULL, "avg_temperatures" FLOAT NOT NULL, "max_temperature" FLOAT NOT NULL , PRIMARY KEY ("sensorid"));
CREATE TABLE IF NOT EXISTS "SensorMaxTempLastMin_3" ("sensorid" INTEGER NOT NULL, "endOfMin" TIMESTAMP WITH TIME ZONE NOT NULL, "avg_temperature" FLOAT NOT NULL , PRIMARY KEY ("sensorid"));
CREATE TABLE IF NOT EXISTS "SensorReading_4" ("sensorid" INTEGER NOT NULL, "temperature" FLOAT NOT NULL, "event_time" TIMESTAMP WITH TIME ZONE , "__pk_hash" TEXT  , PRIMARY KEY ("__pk_hash"))

>>>postgres-views.sql
CREATE OR REPLACE VIEW "SensorAnalysis"("sensorid", "avg_temperatures", "max_temperature") AS SELECT *
FROM (SELECT "sensorid", "avg_temperatures", "max_temperature"
  FROM "SensorAnalysis_2"
  ORDER BY "sensorid" DESC NULLS LAST) AS "t1";
CREATE OR REPLACE VIEW "SensorMaxTempLastMin"("sensorid", "endOfMin", "avg_temperature") AS SELECT *
FROM "SensorMaxTempLastMin_3";
CREATE OR REPLACE VIEW "SensorReading"("sensorid", "temperature", "event_time") AS SELECT "sensorid", "temperature", "event_time"
FROM "SensorReading_4"
>>>postgres.json
{
  "statements" : [
    {
      "name" : "SensorAnalysis_2",
      "type" : "TABLE",
      "sql" : "CREATE TABLE IF NOT EXISTS \"SensorAnalysis_2\" (\"sensorid\" INTEGER NOT NULL, \"avg_temperatures\" FLOAT NOT NULL, \"max_temperature\" FLOAT NOT NULL , PRIMARY KEY (\"sensorid\"))",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "avg_temperatures",
          "type" : "FLOAT",
          "nullable" : false
        },
        {
          "name" : "max_temperature",
          "type" : "FLOAT",
          "nullable" : false
        }
      ]
    },
    {
      "name" : "SensorMaxTempLastMin_3",
      "type" : "TABLE",
      "sql" : "CREATE TABLE IF NOT EXISTS \"SensorMaxTempLastMin_3\" (\"sensorid\" INTEGER NOT NULL, \"endOfMin\" TIMESTAMP WITH TIME ZONE NOT NULL, \"avg_temperature\" FLOAT NOT NULL , PRIMARY KEY (\"sensorid\"))",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "endOfMin",
          "type" : "TIMESTAMP WITH TIME ZONE",
          "nullable" : false
        },
        {
          "name" : "avg_temperature",
          "type" : "FLOAT",
          "nullable" : false
        }
      ]
    },
    {
      "name" : "SensorReading_4",
      "type" : "TABLE",
      "sql" : "CREATE TABLE IF NOT EXISTS \"SensorReading_4\" (\"sensorid\" INTEGER NOT NULL, \"temperature\" FLOAT NOT NULL, \"event_time\" TIMESTAMP WITH TIME ZONE , \"__pk_hash\" TEXT  , PRIMARY KEY (\"__pk_hash\"))",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "temperature",
          "type" : "FLOAT",
          "nullable" : false
        },
        {
          "name" : "event_time",
          "type" : "TIMESTAMP WITH TIME ZONE",
          "nullable" : true
        },
        {
          "name" : "__pk_hash",
          "type" : "TEXT",
          "nullable" : true
        }
      ]
    },
    {
      "name" : "SensorAnalysis",
      "type" : "VIEW",
      "sql" : "CREATE OR REPLACE VIEW \"SensorAnalysis\"(\"sensorid\", \"avg_temperatures\", \"max_temperature\") AS SELECT *\nFROM (SELECT \"sensorid\", \"avg_temperatures\", \"max_temperature\"\n  FROM \"SensorAnalysis_2\"\n  ORDER BY \"sensorid\" DESC NULLS LAST) AS \"t1\"",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "avg_temperatures",
          "type" : "FLOAT",
          "nullable" : false
        },
        {
          "name" : "max_temperature",
          "type" : "FLOAT",
          "nullable" : false
        }
      ]
    },
    {
      "name" : "SensorMaxTempLastMin",
      "type" : "VIEW",
      "sql" : "CREATE OR REPLACE VIEW \"SensorMaxTempLastMin\"(\"sensorid\", \"endOfMin\", \"avg_temperature\") AS SELECT *\nFROM \"SensorMaxTempLastMin_3\"",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "endOfMin",
          "type" : "TIMESTAMP WITH TIME ZONE",
          "nullable" : false
        },
        {
          "name" : "avg_temperature",
          "type" : "FLOAT",
          "nullable" : false
        }
      ]
    },
    {
      "name" : "SensorReading",
      "type" : "VIEW",
      "sql" : "CREATE OR REPLACE VIEW \"SensorReading\"(\"sensorid\", \"temperature\", \"event_time\") AS SELECT \"sensorid\", \"temperature\", \"event_time\"\nFROM \"SensorReading_4\"",
      "fields" : [
        {
          "name" : "sensorid",
          "type" : "INTEGER",
          "nullable" : false
        },
        {
          "name" : "temperature",
          "type" : "FLOAT",
          "nullable" : false
        },
        {
          "name" : "event_time",
          "type" : "TIMESTAMP WITH TIME ZONE",
          "nullable" : true
        }
      ]
    }
  ]
}
>>>vertx.json
{ }
