>>>pipeline_explain.txt
=== HighTempAlert
ID:     default_catalog.default_database.HighTempAlert
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Primary Key: -
Timestamp  : event_time
Schema:
 - sensorid: INTEGER NOT NULL
 - temperature: FLOAT NOT NULL
 - event_time: TIMESTAMP_LTZ(3) *ROWTIME*
Plan:
LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
  LogicalFilter(condition=[>($1, 50)])
    LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW HighTempAlert AS  SELECT * FROM SensorReading WHERE temperature > 50;

=== SensorAnalysis
ID:     default_catalog.default_database.SensorAnalysis
Type:   state
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Annotations:
 - sort: [0 DESC-nulls-last]
Primary Key: sensorid
Timestamp  : -
Schema:
 - sensorid: INTEGER NOT NULL
 - avg_temperatures: FLOAT NOT NULL
 - max_temperature: FLOAT NOT NULL
Plan:
LogicalAggregate(group=[{0}], avg_temperatures=[AVG($1)], max_temperature=[MAX($1)])
  LogicalProject(sensorid=[$0], temperature=[$1])
    LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW SensorAnalysis AS  SELECT sensorid, AVG(temperature) AS avg_temperatures,
                           MAX(temperature) AS max_temperature
                    FROM SensorReading GROUP BY sensorid ORDER BY sensorid DESC;

=== SensorAnalysisById
ID:     default_catalog.default_database.SensorAnalysisById
Type:   query
Stage:  postgres
Inputs: default_catalog.default_database.SensorAnalysis
Annotations:
 - parameters: sensorid
 - base-table: SensorAnalysis
Plan:
LogicalProject(sensorid=[$0], avg_temperatures=[$1], max_temperature=[$2])
  LogicalFilter(condition=[=($0, ?0)])
    LogicalTableScan(table=[[default_catalog, default_database, SensorAnalysis]])
SQL: CREATE VIEW SensorAnalysisById AS  SELECT * FROM SensorAnalysis WHERE sensorid = ?        ;

=== SensorMaxTempLastMin
ID:     default_catalog.default_database.SensorMaxTempLastMin
Type:   state
Stage:  flink
Inputs: default_catalog.default_database._SensorMaxTempLastMinWindow
Annotations:
 - mostRecentDistinct: true
Primary Key: sensorid
Timestamp  : endOfMin
Schema:
 - sensorid: INTEGER NOT NULL
 - endOfMin: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avg_temperature: FLOAT NOT NULL
Plan:
LogicalProject(sensorid=[$0], endOfMin=[$1], avg_temperature=[$2])
  LogicalFilter(condition=[=($3, 1)])
    LogicalProject(sensorid=[$0], endOfMin=[$1], avg_temperature=[$2], __sqrlinternal_rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $1 DESC NULLS LAST)])
      LogicalTableScan(table=[[default_catalog, default_database, _SensorMaxTempLastMinWindow]])
SQL: CREATE VIEW `SensorMaxTempLastMin`
AS
SELECT `sensorid`, `endOfMin`, `avg_temperature`
FROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1
=== SensorReading
ID:     default_catalog.default_database.SensorReading
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading__def
Primary Key: -
Timestamp  : event_time
Schema:
 - sensorid: INTEGER NOT NULL
 - temperature: FLOAT NOT NULL
 - event_time: TIMESTAMP_LTZ(3) *ROWTIME*
Plan:
LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
  LogicalWatermarkAssigner(rowtime=[event_time], watermark=[-($2, 0:INTERVAL SECOND)])
    LogicalProject(sensorid=[$0], temperature=[$1], event_time=[CAST($2):TIMESTAMP_LTZ(3) *ROWTIME*])
      LogicalTableScan(table=[[default_catalog, default_database, SensorReading__def, metadata=[timestamp]]])
SQL: CREATE VIEW `SensorReading`
AS
SELECT *
FROM `default_catalog`.`default_database`.`SensorReading__def`
=== _SensorMaxTempLastMinWindow
ID:     default_catalog.default_database._SensorMaxTempLastMinWindow
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Annotations:
 - features: STREAM_WINDOW_AGGREGATION (feature)
Primary Key: -
Timestamp  : endOfMin
Schema:
 - sensorid: INTEGER NOT NULL
 - endOfMin: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avg_temperature: FLOAT NOT NULL
Plan:
LogicalProject(sensorid=[$0], endOfMin=[$3], avg_temperature=[$4])
  LogicalAggregate(group=[{0, 1, 2, 3}], avg_temperature=[AVG($4)])
    LogicalProject(sensorid=[$0], window_start=[$3], window_end=[$4], endOfMin=[$5], temperature=[$1])
      LogicalTableFunctionScan(invocation=[HOP(DESCRIPTOR($2), 10000:INTERVAL SECOND, 60000:INTERVAL MINUTE)], rowType=[RecordType(INTEGER sensorid, FLOAT temperature, TIMESTAMP_LTZ(3) *ROWTIME* event_time, TIMESTAMP(3) window_start, TIMESTAMP(3) window_end, TIMESTAMP_LTZ(3) *ROWTIME* window_time)])
        LogicalProject(sensorid=[$0], temperature=[$1], event_time=[$2])
          LogicalTableScan(table=[[default_catalog, default_database, SensorReading]])
SQL: CREATE VIEW _SensorMaxTempLastMinWindow AS  SELECT sensorid, window_time as endOfMin,
                                      AVG(temperature) AS avg_temperature
                     FROM TABLE(HOP(TABLE SensorReading, DESCRIPTOR(event_time), INTERVAL '10' SECONDS, INTERVAL '1' MINUTES))
                     GROUP BY sensorid, window_start, window_end, window_time;

>>>flink-sql-no-functions.sql
CREATE TABLE `SensorReading__def` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP_LTZ(3) METADATA FROM 'timestamp',
  WATERMARK FOR `event_time` AS `event_time` - INTERVAL '0.0' SECOND
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'SensorReading'
);
CREATE VIEW `SensorReading`
AS
SELECT *
FROM `default_catalog`.`default_database`.`SensorReading__def`;
CREATE VIEW `HighTempAlert`
AS
SELECT *
FROM `SensorReading`
WHERE `temperature` > 50;
CREATE VIEW `_SensorMaxTempLastMinWindow`
AS
SELECT `sensorid`, `window_time` AS `endOfMin`, AVG(`temperature`) AS `avg_temperature`
FROM TABLE(HOP(TABLE `SensorReading`, DESCRIPTOR(`event_time`), INTERVAL '10' SECOND, INTERVAL '1' MINUTE))
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`;
CREATE VIEW `SensorMaxTempLastMin`
AS
SELECT `sensorid`, `endOfMin`, `avg_temperature`
FROM (SELECT `sensorid`, `endOfMin`, `avg_temperature`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `endOfMin` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1;
CREATE VIEW `SensorAnalysis`
AS
SELECT `sensorid`, AVG(`temperature`) AS `avg_temperatures`, MAX(`temperature`) AS `max_temperature`
FROM `SensorReading`
GROUP BY `sensorid`;
CREATE TABLE `HighTempAlert_1` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE
) WITH (
  'connector' = 'kafka',
  'format' = 'flexible-json',
  'properties.bootstrap.servers' = '${PROPERTIES_BOOTSTRAP_SERVERS}',
  'properties.group.id' = '${PROPERTIES_GROUP_ID}',
  'scan.startup.mode' = 'group-offsets',
  'properties.auto.offset.reset' = 'earliest',
  'topic' = 'HighTempAlert'
);
CREATE TABLE `SensorAnalysis_2` (
  `sensorid` INTEGER NOT NULL,
  `avg_temperatures` FLOAT NOT NULL,
  `max_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_AUTHORITY}',
  'table-name' = 'SensorAnalysis_2'
);
CREATE TABLE `SensorMaxTempLastMin_3` (
  `sensorid` INTEGER NOT NULL,
  `endOfMin` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `avg_temperature` FLOAT NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_AUTHORITY}',
  'table-name' = 'SensorMaxTempLastMin_3'
);
CREATE TABLE `SensorReading_4` (
  `sensorid` INTEGER NOT NULL,
  `temperature` FLOAT NOT NULL,
  `event_time` TIMESTAMP(3) WITH LOCAL TIME ZONE,
  `__pk_hash` CHAR(32) CHARACTER SET `UTF-16LE`,
  PRIMARY KEY (`__pk_hash`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'password' = '${JDBC_PASSWORD}',
  'driver' = 'org.postgresql.Driver',
  'username' = '${JDBC_USERNAME}',
  'url' = 'jdbc:postgresql://${JDBC_AUTHORITY}',
  'table-name' = 'SensorReading_4'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`HighTempAlert_1`
(SELECT *
 FROM `default_catalog`.`default_database`.`HighTempAlert`)
;
INSERT INTO `default_catalog`.`default_database`.`SensorAnalysis_2`
 (SELECT *
  FROM `default_catalog`.`default_database`.`SensorAnalysis`)
 ;
 INSERT INTO `default_catalog`.`default_database`.`SensorMaxTempLastMin_3`
  (SELECT *
   FROM `default_catalog`.`default_database`.`_SensorMaxTempLastMinWindow`)
  ;
  INSERT INTO `default_catalog`.`default_database`.`SensorReading_4`
   (SELECT `sensorid`, `temperature`, `event_time`, HASHCOLUMNS(`sensorid`, `temperature`, `event_time`) AS `__pk_hash`
    FROM `default_catalog`.`default_database`.`SensorReading`)
   ;
   END
>>>kafka.json
{
  "topics" : [
    {
      "name" : "HighTempAlert",
      "numPartitions" : 1,
      "replicationFactor" : 1,
      "replicasAssignments" : { },
      "config" : { }
    },
    {
      "name" : "SensorReading",
      "numPartitions" : 1,
      "replicationFactor" : 1,
      "replicasAssignments" : { },
      "config" : { }
    }
  ]
}
>>>postgres-schema.sql
CREATE TABLE IF NOT EXISTS "SensorAnalysis_2" ("sensorid" INTEGER NOT NULL, "avg_temperatures" FLOAT NOT NULL, "max_temperature" FLOAT NOT NULL , PRIMARY KEY ("sensorid"));
CREATE TABLE IF NOT EXISTS "SensorMaxTempLastMin_3" ("sensorid" INTEGER NOT NULL, "endOfMin" TIMESTAMP WITH TIME ZONE NOT NULL, "avg_temperature" FLOAT NOT NULL , PRIMARY KEY ("sensorid"));
CREATE TABLE IF NOT EXISTS "SensorReading_4" ("sensorid" INTEGER NOT NULL, "temperature" FLOAT NOT NULL, "event_time" TIMESTAMP WITH TIME ZONE , "__pk_hash" TEXT  , PRIMARY KEY ("__pk_hash"))
>>>postgres-views.sql
CREATE OR REPLACE VIEW "SensorAnalysis"("sensorid", "avg_temperatures", "max_temperature") AS SELECT *
FROM (SELECT "sensorid", "avg_temperatures", "max_temperature"
  FROM "SensorAnalysis_2"
  ORDER BY "sensorid" DESC NULLS LAST) AS "t1";
CREATE OR REPLACE VIEW "SensorMaxTempLastMin"("sensorid", "endOfMin", "avg_temperature") AS SELECT *
FROM "SensorMaxTempLastMin_3";
CREATE OR REPLACE VIEW "SensorReading"("sensorid", "temperature", "event_time") AS SELECT "sensorid", "temperature", "event_time"
FROM "SensorReading_4"
>>>vertx.json
{ }
