>>>pipeline_explain.txt
=== _OrderItems
ID:     _orderitems$1
Type:   stream
Stage:  streams
Inputs: orders$2
Primary Key: id, time, productid
Timestamp  : time
Schema:
 - id: BIGINT NOT NULL
 - time: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - customerid: BIGINT NOT NULL
 - productid: BIGINT NOT NULL
 - quantity: BIGINT NOT NULL
 - unit_price: DOUBLE NOT NULL
 - discount: DOUBLE
Plan:
LogicalProject(id=[$0], time=[$2], customerid=[$1], productid=[$4], quantity=[$5], unit_price=[$6], discount=[$7])
  LogicalCorrelate(correlation=[$cor8], joinType=[inner], requiredColumns=[{3}])
    LogicalTableScan(table=[[orders$2]])
    LogicalTableFunctionScan(invocation=[Orders.items($cor8.items)], rowType=[RecordType(BIGINT productid, BIGINT quantity, DOUBLE unit_price, DOUBLE discount)], elementType=[class [Ljava.lang.Object;])

=== Customers
ID:     customers$2
Type:   stream
Stage:  streams
Primary Key: id, changed_on
Timestamp  : timestamp
Schema:
 - id: BIGINT NOT NULL
 - first_name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - last_name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - email: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - ip_address: VARCHAR(2147483647) CHARACTER SET "UTF-16LE"
 - country: VARCHAR(2147483647) CHARACTER SET "UTF-16LE"
 - changed_on: BIGINT NOT NULL
 - timestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalTableScan(table=[[customers$1]], hints=[[[WatermarkHint inheritPath:[] options:[7]]]]) hints[WatermarkHint options:[7]]

=== Customers
ID:     customers$3
Type:   state
Stage:  streams
Inputs: customers$2
Primary Key: id
Timestamp  : timestamp
Schema:
 - id: BIGINT NOT NULL
 - first_name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - last_name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - email: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - ip_address: VARCHAR(2147483647) CHARACTER SET "UTF-16LE"
 - country: VARCHAR(2147483647) CHARACTER SET "UTF-16LE"
 - changed_on: BIGINT NOT NULL
 - timestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - country0: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
Post Processors:
 - topN: partition=id limit=1 sort=#7: timestamp TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalProject(id=[$0], first_name=[$1], last_name=[$2], email=[$3], ip_address=[$4], country=[$5], changed_on=[$6], timestamp=[$7], country0=[COALESCE($5, 'none')])
  LogicalTableScan(table=[[customers$2]])

=== monthly_by_country
ID:     monthly_by_country$1
Type:   stream
Stage:  streams
Inputs: _orderitems$1, customers$3, products$3
Primary Key: __pk1$id, country, month
Timestamp  : month
Schema:
 - __pk1$id: BIGINT NOT NULL
 - country: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - month: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - quantity: BIGINT NOT NULL
 - spend: DOUBLE NOT NULL
 - weight: BIGINT NOT NULL
Plan:
LogicalProject(__pk1$id=[$0], country=[$1], month=[$2], quantity=[$3], spend=[$4], weight=[$5])
  LogicalAggregate(group=[{0, 1, 2}], quantity=[SUM($3)], spend=[SUM($4)], weight=[SUM($5)]) hints[TumbleAggregationHint options:[2, FUNCTION, 7, 2629746000, 0]]
    LogicalProject(__pk6$id=[$7], country=[$24], month=[endOfMonth($1)], quantity=[$4], $f4=[*($4, $5)], $f5=[*($4, $10)], id=[$0], time=[$1], productid=[$3])
      LogicalJoin(condition=[=($2, $16)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
        LogicalJoin(condition=[=($3, $7)], joinType=[inner]) hints[TemporalJoinHint options:[1]]
          LogicalTableScan(table=[[_orderitems$1]])
          LogicalFilter(condition=[=($8, 1)]) hints[DedupHint]
            LogicalProject(id=[$0], name=[$1], sizing=[$2], weight_in_gram=[$3], type=[$4], category=[$5], usda_id=[$6], updated=[$7], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $7 DESC NULLS LAST)])
              LogicalTableScan(table=[[products$3]])
        LogicalFilter(condition=[=($9, 1)]) hints[DedupHint]
          LogicalProject(id=[$0], first_name=[$1], last_name=[$2], email=[$3], ip_address=[$4], country=[$5], changed_on=[$6], timestamp=[$7], country0=[$8], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $7 DESC NULLS LAST)])
            LogicalTableScan(table=[[customers$3]])

=== NumOrders
ID:     numorders$1
Type:   state
Stage:  streams
Inputs: orders$2
Primary Key: __pk
Timestamp  : __timestamp
Schema:
 - count: BIGINT NOT NULL
 - __pk: INTEGER NOT NULL
 - __timestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3)
Plan:
LogicalProject(count=[$0], __pk=[1], __timestamp=[$1])
  LogicalAggregate(group=[{}], count=[COUNT()], __timestamp=[MAX($2)])
    LogicalTableScan(table=[[orders$2]])

=== order_stats
ID:     order_stats$1
Type:   state
Stage:  streams
Inputs: customers$3, orders$2, totals$1
Primary Key: __pk1$id
Timestamp  : __timestamp
Schema:
 - __pk1$id: BIGINT NOT NULL
 - total_spend: DOUBLE NOT NULL
 - total_saved: DOUBLE NOT NULL
 - num_orders: BIGINT NOT NULL
 - __timestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalProject(__pk1$id=[$0], total_spend=[$1], total_saved=[$2], num_orders=[$3], __timestamp=[$4])
  LogicalAggregate(group=[{0}], total_spend=[SUM($7)], total_saved=[SUM($8)], num_orders=[COUNT()], __timestamp=[MAX($3)])
    LogicalJoin(condition=[AND(=($1, $5), =($3, $6))], joinType=[inner]) hints[IntervalJoin]
      LogicalProject(__pk4$id=[$5], id=[$0], customerid=[$1], time=[$2], items=[$3])
        LogicalJoin(condition=[=($5, $4)], joinType=[inner]) hints[TemporalJoinHint options:[2]]
          LogicalProject(id=[$0], customerid=[$1], time=[$2], items=[$3], customerid4=[$1])
            LogicalTableScan(table=[[orders$2]])
          LogicalFilter(condition=[=($9, 1)]) hints[DedupHint]
            LogicalProject(id=[$0], first_name=[$1], last_name=[$2], email=[$3], ip_address=[$4], country=[$5], changed_on=[$6], timestamp=[$7], country0=[$8], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $7 DESC NULLS LAST)])
              LogicalTableScan(table=[[customers$3]])
      LogicalTableScan(table=[[totals$1]])

=== Orders
ID:     orders$2
Type:   stream
Stage:  streams
Primary Key: id, time
Timestamp  : time
Schema:
 - id: BIGINT NOT NULL
 - customerid: BIGINT NOT NULL
 - time: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - items: RecordType(BIGINT NOT NULL productid, BIGINT NOT NULL quantity, DOUBLE NOT NULL unit_price, DOUBLE discount) NOT NULL ARRAY NOT NULL
Plan:
LogicalTableScan(table=[[orders$1]], hints=[[[WatermarkHint inheritPath:[] options:[2]]]]) hints[WatermarkHint options:[2]]

=== past_purchases
ID:     past_purchases$1
Type:   state
Stage:  streams
Inputs: customers$3, orders$2
Primary Key: __pk1$id, productid
Timestamp  : __timestamp
Schema:
 - __pk1$id: BIGINT NOT NULL
 - productid: BIGINT NOT NULL
 - num_orders: BIGINT NOT NULL
 - total_quantity: BIGINT NOT NULL
 - __timestamp: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - sort: #0: __pk1$id BIGINT ASC, #2: num_orders BIGINT DESC, #3: total_quantity BIGINT DESC
Plan:
LogicalProject(__pk1$id=[$0], productid=[$1], num_orders=[$2], total_quantity=[$3], __timestamp=[$4])
  LogicalAggregate(group=[{4, 14}], num_orders=[COUNT()], total_quantity=[SUM($15)], __timestamp=[MAX($2)])
    LogicalCorrelate(correlation=[$cor7], joinType=[inner], requiredColumns=[{3}])
      LogicalJoin(condition=[=($1, $4)], joinType=[inner]) hints[TemporalJoinHint options:[2]]
        LogicalTableScan(table=[[orders$2]])
        LogicalFilter(condition=[=($9, 1)]) hints[DedupHint]
          LogicalProject(id=[$0], first_name=[$1], last_name=[$2], email=[$3], ip_address=[$4], country=[$5], changed_on=[$6], timestamp=[$7], country0=[$8], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $7 DESC NULLS LAST)])
            LogicalTableScan(table=[[customers$3]])
      LogicalTableFunctionScan(invocation=[Orders.items($cor7.items)], rowType=[RecordType(BIGINT productid, BIGINT quantity, DOUBLE unit_price, DOUBLE discount)], elementType=[class [Ljava.lang.Object;])

=== Products
ID:     products$2
Type:   stream
Stage:  streams
Primary Key: id, updated
Timestamp  : updated
Schema:
 - id: BIGINT NOT NULL
 - name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - sizing: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - weight_in_gram: BIGINT NOT NULL
 - type: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - category: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - usda_id: BIGINT NOT NULL
 - updated: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Plan:
LogicalTableScan(table=[[products$1]], hints=[[[WatermarkHint inheritPath:[] options:[7]]]]) hints[WatermarkHint options:[7]]

=== Products
ID:     products$3
Type:   state
Stage:  streams
Inputs: products$2
Primary Key: id
Timestamp  : updated
Schema:
 - id: BIGINT NOT NULL
 - name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - sizing: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - weight_in_gram: BIGINT NOT NULL
 - type: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - category: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - usda_id: BIGINT NOT NULL
 - updated: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
Post Processors:
 - topN: partition=id limit=1 sort=#7: updated TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC-nulls-last 
Plan:
LogicalTableScan(table=[[products$2]])

=== spending
ID:     spending$1
Type:   stream
Stage:  streams
Inputs: customers$3, orders$2, totals$1
Primary Key: __pk1$id, week
Timestamp  : week
Schema:
 - __pk1$id: BIGINT NOT NULL
 - week: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - spend: DOUBLE NOT NULL
 - saved: DOUBLE NOT NULL
Post Processors:
 - sort: #0: __pk1$id BIGINT ASC, #1: week TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) DESC
Plan:
LogicalProject(__pk1$id=[$0], week=[$1], spend=[$2], saved=[$3])
  LogicalAggregate(group=[{0, 1}], spend=[SUM($2)], saved=[SUM($3)]) hints[TumbleAggregationHint options:[1, FUNCTION, 5, 604800000, 0]]
    LogicalProject(__pk3$id=[$0], week=[endOfWeek($3)], price=[$7], saving=[$8], id=[$1], time=[$3])
      LogicalJoin(condition=[AND(=($1, $5), =($3, $6))], joinType=[inner]) hints[IntervalJoin]
        LogicalProject(__pk3$id=[$5], id=[$0], customerid=[$1], time=[$2], items=[$3])
          LogicalJoin(condition=[=($5, $4)], joinType=[inner]) hints[TemporalJoinHint options:[2]]
            LogicalProject(id=[$0], customerid=[$1], time=[$2], items=[$3], customerid4=[$1])
              LogicalTableScan(table=[[orders$2]])
            LogicalFilter(condition=[=($9, 1)]) hints[DedupHint]
              LogicalProject(id=[$0], first_name=[$1], last_name=[$2], email=[$3], ip_address=[$4], country=[$5], changed_on=[$6], timestamp=[$7], country0=[$8], _rownum=[ROW_NUMBER() OVER (PARTITION BY $0 ORDER BY $7 DESC NULLS LAST)])
                LogicalTableScan(table=[[customers$3]])
        LogicalTableScan(table=[[totals$1]])

=== totals
ID:     totals$1
Type:   stream
Stage:  streams
Inputs: orders$2
Primary Key: __pk1$id, __pk3$time
Timestamp  : __pk3$time
Schema:
 - __pk1$id: BIGINT NOT NULL
 - __pk3$time: TIMESTAMP_WITH_LOCAL_TIME_ZONE(3) NOT NULL
 - price: DOUBLE NOT NULL
 - saving: DOUBLE NOT NULL
Plan:
LogicalProject(__pk1$id=[$0], __pk3$time=[$1], price=[$2], saving=[$3])
  LogicalAggregate(group=[{0, 1}], agg#0=[SUM($2)], agg#1=[SUM($3)]) hints[TumbleAggregationHint options:[1, INSTANT, 1, 1, 0]]
    LogicalProject(__pk1$id=[$0], __pk2$time=[$2], $f2=[-(*($5, $6), COALESCE($7, 0.0:DECIMAL(2, 1)))], $f3=[COALESCE($7, 0.0:DECIMAL(2, 1))], productid=[$4])
      LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{3}])
        LogicalTableScan(table=[[orders$2]])
        LogicalTableFunctionScan(invocation=[Orders.items($cor0.items)], rowType=[RecordType(BIGINT productid, BIGINT quantity, DOUBLE unit_price, DOUBLE discount)], elementType=[class [Ljava.lang.Object;])

>>>schema.graphqls
type Customers {
  id: Float!
  first_name: String!
  last_name: String!
  email: String!
  ip_address: String
  country: String
  changed_on: Float!
  timestamp: DateTime!
  country0: String!
  order_stats: order_stats
  past_purchases(productid: Float, limit: Int = 10, offset: Int = 0): [past_purchases!]
  purchases(limit: Int = 10, offset: Int = 0): [Orders!]
  spending(week: DateTime, limit: Int = 10, offset: Int = 0): [spending!]
}

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

type NumOrders {
  count: Float!
}

type Orders {
  id: Float!
  customerid: Float!
  time: DateTime!
  customer(limit: Int = 10, offset: Int = 0): [Customers!]
  items(limit: Int = 10, offset: Int = 0): [items!]
  totals: totals
}

type Products {
  id: Float!
  name: String!
  sizing: String!
  weight_in_gram: Float!
  type: String!
  category: String!
  usda_id: Float!
  updated: DateTime!
  monthly_by_country(country: String, month: DateTime, limit: Int = 10, offset: Int = 0): [monthly_by_country!]
}

type Query {
  Customers(id: Float, limit: Int = 10, offset: Int = 0): [Customers!]
  NumOrders(limit: Int = 10, offset: Int = 0): [NumOrders!]
  Orders(id: Float, time: DateTime, limit: Int = 10, offset: Int = 0): [Orders!]
  Products(id: Float, limit: Int = 10, offset: Int = 0): [Products!]
}

type items {
  productid: Float!
  quantity: Float!
  unit_price: Float!
  discount: Float
}

type monthly_by_country {
  country: String!
  month: DateTime!
  quantity: Float!
  spend: Float!
  weight: Float!
  parent: Products!
}

type order_stats {
  total_spend: Float!
  total_saved: Float!
  num_orders: Float!
  parent: Customers!
}

type past_purchases {
  productid: Float!
  num_orders: Float!
  total_quantity: Float!
  parent: Customers!
}

type spending {
  week: DateTime!
  spend: Float!
  saved: Float!
  parent: Customers!
}

type totals {
  price: Float!
  saving: Float!
  parent: Orders!
}

