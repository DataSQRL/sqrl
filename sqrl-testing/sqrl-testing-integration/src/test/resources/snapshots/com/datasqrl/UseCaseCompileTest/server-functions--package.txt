>>>pipeline_explain.txt
=== Customers
ID:     default_catalog.default_database.Customers
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.Customers__base
Annotations:
 - stream-root: Customers
Primary Key: customerid, lastUpdated
Timestamp  : timestamp
Schema:
 - customerid: BIGINT NOT NULL
 - email: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - name: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - lastUpdated: BIGINT NOT NULL
 - timestamp: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
Plan:
LogicalWatermarkAssigner(rowtime=[timestamp], watermark=[-($4, 1:INTERVAL SECOND)])
  LogicalProject(customerid=[$0], email=[$1], name=[$2], lastUpdated=[$3], timestamp=[COALESCE(TO_TIMESTAMP_LTZ($3, 0), 1970-01-01 08:00:00:TIMESTAMP_WITH_LOCAL_TIME_ZONE(3))])
    LogicalTableScan(table=[[default_catalog, default_database, Customers]])
SQL: CREATE VIEW `Customers__view`
AS
SELECT `Customers`.`customerid`, `Customers`.`email`, `Customers`.`name`, `Customers`.`lastUpdated`, `Customers`.`timestamp`
FROM `default_catalog`.`default_database`.`Customers` AS `Customers`
=== CustomersByName
ID:     default_catalog.default_database.CustomersByName
Type:   query
Stage:  postgres
Inputs: default_catalog.default_database.Customers
Annotations:
 - stream-root: Customers
 - parameters: inputName, shortName
 - base-table: Customers
Plan:
LogicalProject(customerid=[$0], email=[$1], name=[$2], lastUpdated=[$3], timestamp=[$4])
  LogicalFilter(condition=[LIKE($2, ?1)])
    LogicalTableScan(table=[[default_catalog, default_database, Customers]])
SQL: CREATE VIEW `CustomersByName` AS 
    SELECT * FROM Customers WHERE name LIKE ?         ;

=== CustomersByNames
ID:     default_catalog.default_database.CustomersByNames
Type:   query
Stage:  postgres
Inputs: default_catalog.default_database.Customers
Annotations:
 - stream-root: Customers
 - parameters: nameList, nameSplit
 - base-table: Customers
Plan:
LogicalProject(customerid=[$0], email=[$1], name=[$2], lastUpdated=[$3], timestamp=[$4])
  LogicalFilter(condition=[ARRAY_CONTAINS(CAST(?1):VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL ARRAY, $2)])
    LogicalTableScan(table=[[default_catalog, default_database, Customers]])
SQL: CREATE VIEW `CustomersByNames` AS 
    SELECT * FROM Customers WHERE ARRAY_CONTAINS(CAST(?          AS STRING ARRAY), name);

>>>flink-sql-no-functions.sql
CREATE TEMPORARY TABLE `Customers__schema` (
  `customerid` BIGINT NOT NULL,
  `email` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `name` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `lastUpdated` BIGINT NOT NULL
) WITH (
  'connector' = 'filesystem',
  'format' = 'flexible-json',
  'path' = '${DATA_PATH}/customers.jsonl'
);
CREATE TABLE `Customers` (
  `timestamp` AS COALESCE(`TO_TIMESTAMP_LTZ`(`lastUpdated`, 0), TIMESTAMP '1970-01-01 00:00:00.000'),
  PRIMARY KEY (`customerid`, `lastUpdated`) NOT ENFORCED,
  WATERMARK FOR `timestamp` AS `timestamp` - INTERVAL '0.001' SECOND
) WITH (
  'source.monitor-interval' = '10 sec'
)
LIKE `Customers__schema`;
CREATE TABLE `Customers_1` (
  `customerid` BIGINT NOT NULL,
  `email` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `name` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `lastUpdated` BIGINT NOT NULL,
  `timestamp` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`customerid`, `lastUpdated`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'Customers',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`Customers_1`
SELECT *
 FROM `default_catalog`.`default_database`.`Customers`
;
END
>>>kafka.json
{
  "topics" : [ ],
  "testRunnerTopics" : [ ]
}
>>>postgres-schema.sql
CREATE TABLE IF NOT EXISTS "Customers" ("customerid" BIGINT NOT NULL, "email" TEXT NOT NULL, "name" TEXT NOT NULL, "lastUpdated" BIGINT NOT NULL, "timestamp" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("customerid","lastUpdated"))
>>>postgres-views.sql

>>>vertx.json
{
  "models" : {
    "v1" : {
      "queries" : [
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "Customers",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Customers\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "CustomersByName",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "shortName"
              },
              {
                "type" : "variable",
                "path" : "offset"
              },
              {
                "type" : "variable",
                "path" : "inputName"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Customers\"\nWHERE \"name\" LIKE $2",
              "parameters" : [
                {
                  "type" : "arg",
                  "path" : "inputName"
                },
                {
                  "type" : "computed",
                  "functionId" : "SqrlExecFn0"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "CustomersByNames",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "nameList"
              },
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              },
              {
                "type" : "variable",
                "path" : "nameSplit"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Customers\"\nWHERE (\"name\" = ANY (CAST($2 AS TEXT ARRAY)))",
              "parameters" : [
                {
                  "type" : "arg",
                  "path" : "nameList"
                },
                {
                  "type" : "computed",
                  "functionId" : "SqrlExecFn1"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        }
      ],
      "mutations" : [ ],
      "subscriptions" : [ ],
      "operations" : [
        {
          "function" : {
            "name" : "GetCustomers",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query Customers($limit: Int = 10, $offset: Int = 0) {\nCustomers(limit: $limit, offset: $offset) {\ncustomerid\nemail\nname\nlastUpdated\ntimestamp\n}\n\n}",
            "queryName" : "Customers",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/Customers{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetCustomersByName",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                },
                "shortName" : {
                  "type" : "string"
                },
                "inputName" : {
                  "type" : "string"
                }
              },
              "required" : [
                "inputName"
              ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query CustomersByName($inputName: String!, $shortName: String, $limit: Int = 10, $offset: Int = 0) {\nCustomersByName(inputName: $inputName, shortName: $shortName, limit: $limit, offset: $offset) {\ncustomerid\nemail\nname\nlastUpdated\ntimestamp\n}\n\n}",
            "queryName" : "CustomersByName",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/CustomersByName{?offset,limit,shortName,inputName}"
        },
        {
          "function" : {
            "name" : "GetCustomersByNames",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "nameList" : {
                  "type" : "string"
                },
                "limit" : {
                  "type" : "integer"
                },
                "nameSplit" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              },
              "required" : [
                "nameList"
              ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query CustomersByNames($nameList: String!, $nameSplit: [String], $limit: Int = 10, $offset: Int = 0) {\nCustomersByNames(nameList: $nameList, nameSplit: $nameSplit, limit: $limit, offset: $offset) {\ncustomerid\nemail\nname\nlastUpdated\ntimestamp\n}\n\n}",
            "queryName" : "CustomersByNames",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/CustomersByNames{?offset,nameList,limit,nameSplit}"
        }
      ],
      "schema" : {
        "type" : "string",
        "schema" : "type Customers {\n  customerid: Long!\n  email: String!\n  name: String!\n  lastUpdated: Long!\n  timestamp: DateTime!\n}\n\n\"An RFC-3339 compliant Full Date Scalar\"\nscalar Date\n\n\"A DateTime scalar that handles both full RFC3339 and shorter timestamp formats\"\nscalar DateTime\n\n\"A JSON scalar\"\nscalar JSON\n\n\"24-hour clock time value string in the format `hh:mm:ss` or `hh:mm:ss.sss`.\"\nscalar LocalTime\n\n\"A 64-bit signed integer\"\nscalar Long\n\ntype Query {\n  Customers(limit: Int = 10, offset: Int = 0): [Customers!]\n  CustomersByName(inputName: String!, shortName: String, limit: Int = 10, offset: Int = 0): [Customers!]\n  CustomersByNames(nameList: String!, nameSplit: [String], limit: Int = 10, offset: Int = 0): [Customers!]\n}\n\nenum _McpMethodType {\n  NONE\n  TOOL\n  RESOURCE\n}\n\nenum _RestMethodType {\n  NONE\n  GET\n  POST\n}\n\ndirective @api(mcp: _McpMethodType, rest: _RestMethodType, uri: String) on QUERY | MUTATION | FIELD_DEFINITION\n"
      }
    }
  }
}
