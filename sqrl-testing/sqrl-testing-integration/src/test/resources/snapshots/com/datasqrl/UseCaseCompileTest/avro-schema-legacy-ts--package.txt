>>>pipeline_explain.txt
=== Res
ID:     default_catalog.default_database.Res
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database._MySchema
Annotations:
 - stream-root: _MySchema
 - sort: [0 DESC-nulls-last]
Primary Key: uuidField, timestampMillisField
Timestamp  : timestampMillisField
Schema:
 - uuidField: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - timestampMillisField: TIMESTAMP(3) *ROWTIME* NOT NULL
 - nullableTimestampMillisField: TIMESTAMP(3)
Plan:
LogicalProject(uuidField=[$0], timestampMillisField=[$1], nullableTimestampMillisField=[$2])
  LogicalTableScan(table=[[default_catalog, default_database, _MySchema]])
SQL: CREATE VIEW `Res` AS  SELECT * FROM _MySchema ORDER BY uuidField DESC;

=== _MySchema
ID:     default_catalog.default_database._MySchema
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database._MySchema__base
Annotations:
 - stream-root: _MySchema
Primary Key: uuidField, timestampMillisField
Timestamp  : timestampMillisField
Schema:
 - uuidField: VARCHAR(2147483647) CHARACTER SET "UTF-16LE" NOT NULL
 - timestampMillisField: TIMESTAMP(3) *ROWTIME* NOT NULL
 - nullableTimestampMillisField: TIMESTAMP(3)
Plan:
LogicalWatermarkAssigner(rowtime=[timestampMillisField], watermark=[$1])
  LogicalTableScan(table=[[default_catalog, default_database, _MySchema]])
SQL: CREATE VIEW `_MySchema__view`
AS
SELECT `_MySchema`.`uuidField`, `_MySchema`.`timestampMillisField`, `_MySchema`.`nullableTimestampMillisField`
FROM `default_catalog`.`default_database`.`_MySchema` AS `_MySchema`
>>>flink-sql-no-functions.sql
CREATE TEMPORARY TABLE `_MySchema__schema` (
  `uuidField` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `timestampMillisField` TIMESTAMP(3) NOT NULL,
  `nullableTimestampMillisField` TIMESTAMP(3)
) WITH (
  'connector' = 'datagen'
);
CREATE TABLE `_MySchema` (
  PRIMARY KEY (`uuidField`, `timestampMillisField`) NOT ENFORCED,
  WATERMARK FOR `timestampMillisField` AS `timestampMillisField`
) WITH (
  'connector' = 'filesystem',
  'format' = 'avro',
  'path' = '${DATA_PATH}/data.avro',
  'avro.timestamp_mapping.legacy' = 'true'
)
LIKE `_MySchema__schema`;
CREATE VIEW `Res`
AS
SELECT *
FROM `_MySchema`;
CREATE VIEW `MySchema`
AS
SELECT *
FROM `Res`;
CREATE TABLE `Res_1` (
  `uuidField` VARCHAR(2147483647) CHARACTER SET `UTF-16LE` NOT NULL,
  `timestampMillisField` TIMESTAMP(3) NOT NULL,
  `nullableTimestampMillisField` TIMESTAMP(3),
  PRIMARY KEY (`uuidField`, `timestampMillisField`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'Res',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`Res_1`
(SELECT *
 FROM `default_catalog`.`default_database`.`Res`)
;
END
>>>kafka.json
{
  "topics" : [ ],
  "testRunnerTopics" : [ ]
}
>>>postgres-schema.sql
CREATE TABLE IF NOT EXISTS "Res" ("uuidField" TEXT NOT NULL, "timestampMillisField" TIMESTAMP WITHOUT TIME ZONE NOT NULL, "nullableTimestampMillisField" TIMESTAMP WITHOUT TIME ZONE, PRIMARY KEY ("uuidField","timestampMillisField"))
>>>postgres-views.sql

>>>vertx.json
{
  "models" : {
    "v1" : {
      "queries" : [
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "Res",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "offset"
              },
              {
                "type" : "variable",
                "path" : "limit"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM (SELECT \"uuidField\", \"timestampMillisField\", \"nullableTimestampMillisField\"\n  FROM \"Res\"\n  ORDER BY \"uuidField\" DESC NULLS LAST) AS \"t\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        }
      ],
      "mutations" : [ ],
      "subscriptions" : [ ],
      "operations" : [
        {
          "function" : {
            "name" : "GetRes",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query Res($limit: Int = 10, $offset: Int = 0) {\nRes(limit: $limit, offset: $offset) {\nuuidField\ntimestampMillisField\nnullableTimestampMillisField\n}\n\n}",
            "queryName" : "Res",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/Res{?offset,limit}"
        }
      ],
      "schema" : {
        "type" : "string",
        "schema" : "\"An RFC-3339 compliant Full Date Scalar\"\nscalar Date\n\n\"A DateTime scalar that handles both full RFC3339 and shorter timestamp formats\"\nscalar DateTime\n\n\"A JSON scalar\"\nscalar JSON\n\n\"24-hour clock time value string in the format `hh:mm:ss` or `hh:mm:ss.sss`.\"\nscalar LocalTime\n\n\"A 64-bit signed integer\"\nscalar Long\n\ntype Query {\n  Res(limit: Int = 10, offset: Int = 0): [Res!]\n}\n\ntype Res {\n  uuidField: String!\n  timestampMillisField: DateTime!\n  nullableTimestampMillisField: DateTime\n}\n\nenum _McpMethodType {\n  NONE\n  TOOL\n  RESOURCE\n}\n\nenum _RestMethodType {\n  NONE\n  GET\n  POST\n}\n\ndirective @api(mcp: _McpMethodType, rest: _RestMethodType, uri: String) on QUERY | MUTATION | FIELD_DEFINITION\n"
      }
    }
  }
}
