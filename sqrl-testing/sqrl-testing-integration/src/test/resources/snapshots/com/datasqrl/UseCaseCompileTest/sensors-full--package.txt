>>>pipeline_explain.txt
=== HighTemp
ID:     default_catalog.default_database.HighTemp
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SecReading, default_catalog.default_database.Sensors
Annotations:
 - stream-root: SensorReading
Primary Key: sensorid, timeSec
Timestamp  : timeSec
Schema:
 - machineId: BIGINT NOT NULL
 - sensorid: BIGINT NOT NULL
 - temp: DOUBLE NOT NULL
 - timeSec: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL

=== Machine
ID:     default_catalog.default_database.Machine
Type:   state
Stage:  flink
Inputs: default_catalog.default_database.SecReading, default_catalog.default_database.Sensors
Primary Key: machineId
Timestamp  : -
Schema:
 - machineId: BIGINT NOT NULL
 - maxTemp: DOUBLE NOT NULL
 - avgTemp: DOUBLE NOT NULL

=== SecReading
ID:     default_catalog.default_database.SecReading
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading
Annotations:
 - features: STREAM_WINDOW_AGGREGATION (feature)
 - stream-root: SensorReading
 - sort: [1 DESC-nulls-last]
Primary Key: sensorid, timeSec
Timestamp  : timeSec
Schema:
 - sensorid: BIGINT NOT NULL
 - timeSec: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - temp: DOUBLE NOT NULL

=== SecReadingByTemp
ID:     default_catalog.default_database.SecReadingByTemp
Type:   query
Stage:  postgres
Inputs: default_catalog.default_database.SecReading
Annotations:
 - stream-root: SensorReading
 - parameters: temp
 - base-table: SecReading

=== SensorLastHour
ID:     default_catalog.default_database.SensorLastHour
Type:   state
Stage:  flink
Inputs: default_catalog.default_database._SensorMaxTempWindow
Annotations:
 - mostRecentDistinct: true
 - stream-root: SensorReading
Primary Key: sensorid
Timestamp  : window_time
Schema:
 - sensorid: BIGINT NOT NULL
 - window_time: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avgTemp: DOUBLE NOT NULL
 - maxTemp: DOUBLE NOT NULL

=== SensorReading
ID:     default_catalog.default_database.SensorReading
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorReading__base
Annotations:
 - stream-root: SensorReading
Primary Key: sensorid, time
Timestamp  : timestamp
Schema:
 - sensorid: BIGINT NOT NULL
 - time: BIGINT NOT NULL
 - temperature: DOUBLE NOT NULL
 - humidity: DOUBLE NOT NULL
 - timestamp: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL

=== SensorUpdates
ID:     default_catalog.default_database.SensorUpdates
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SensorUpdates__base
Annotations:
 - stream-root: SensorUpdates
Primary Key: id, placed
Timestamp  : timestamp
Schema:
 - id: BIGINT NOT NULL
 - machineId: BIGINT NOT NULL
 - placed: BIGINT NOT NULL
 - timestamp: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL

=== Sensors
ID:     default_catalog.default_database.Sensors
Type:   state
Stage:  flink
Inputs: default_catalog.default_database.SensorUpdates
Annotations:
 - mostRecentDistinct: true
 - stream-root: SensorUpdates
Primary Key: id
Timestamp  : timestamp
Schema:
 - id: BIGINT NOT NULL
 - machineId: BIGINT NOT NULL
 - placed: BIGINT NOT NULL
 - timestamp: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL

=== _SensorMaxTempWindow
ID:     default_catalog.default_database._SensorMaxTempWindow
Type:   stream
Stage:  flink
Inputs: default_catalog.default_database.SecReading
Annotations:
 - features: STREAM_WINDOW_AGGREGATION (feature)
 - stream-root: SensorReading
Primary Key: -
Timestamp  : window_time
Schema:
 - sensorid: BIGINT NOT NULL
 - window_time: TIMESTAMP_LTZ(3) *ROWTIME* NOT NULL
 - avgTemp: DOUBLE NOT NULL
 - maxTemp: DOUBLE NOT NULL

>>>generated-schema.graphqls
"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

type HighTemp {
  machineid: Float!
  sensorid: Float!
  temp: Float!
  timeSec: DateTime!
}

type Machine {
  machineid: Float!
  maxTemp: Float!
  avgTemp: Float!
  sensors(limit: Int = 10, offset: Int = 0): [Sensors!]
}

type Query {
  HighTemp(sensorid: Float, timeSec: DateTime, limit: Int = 10, offset: Int = 0): [HighTemp!]
  Machine(machineid: Float, limit: Int = 10, offset: Int = 0): [Machine!]
  SecReading(sensorid: Float, timeSec: DateTime, limit: Int = 10, offset: Int = 0): [SecReading!]
  SecReadingByTemp(temp: Int!): [SecReadingByTemp!]
  SensorReading(sensorid: Float, time: DateTime, limit: Int = 10, offset: Int = 0): [SensorReading!]
  Sensors(id: Float, limit: Int = 10, offset: Int = 0): [Sensors!]
}

type SecReading {
  sensorid: Float!
  timeSec: DateTime!
  temp: Float!
}

type SecReadingByTemp {
  sensorid: Float!
  timeSec: DateTime!
  temp: Float!
}

type SensorReading {
  sensorid: Float!
  time: DateTime!
  temperature: Float!
  humidity: Float!
}

type Sensors {
  id: Float!
  machineid: Float!
  placed: DateTime!
  lastHour: lastHour
  readings(limit: Int = 10, offset: Int = 0): [SecReading!]
}

type lastHour {
  maxTemp: Float!
  avgTemp: Float!
  parent: Sensors!
}

>>>flink-sql-no-functions.sql
CREATE TEMPORARY TABLE `SensorReading__schema` (
  `sensorid` BIGINT NOT NULL,
  `time` BIGINT NOT NULL,
  `temperature` DOUBLE NOT NULL,
  `humidity` DOUBLE NOT NULL
) WITH (
  'connector' = 'datagen'
);
CREATE TABLE `SensorReading` (
  `timestamp` AS COALESCE(`TO_TIMESTAMP_LTZ`(`time`, 3), TIMESTAMP '1970-01-01 00:00:00.000'),
  PRIMARY KEY (`sensorid`, `time`) NOT ENFORCED,
  WATERMARK FOR `timestamp` AS `timestamp` - INTERVAL '0.001' SECOND
) WITH (
  'format' = 'flexible-csv',
  'path' = '${DATA_PATH}/sensorreading.csv.gz',
  'connector' = 'filesystem',
  'flexible-csv.skip-header' = 'true'
)
LIKE `SensorReading__schema`;
CREATE TEMPORARY TABLE `SensorUpdates__schema` (
  `id` BIGINT NOT NULL,
  `machineId` BIGINT NOT NULL,
  `placed` BIGINT NOT NULL
) WITH (
  'connector' = 'datagen'
);
CREATE TABLE `SensorUpdates` (
  `timestamp` AS COALESCE(`TO_TIMESTAMP_LTZ`(`placed`, 3), TIMESTAMP '1970-01-01 00:00:00.000'),
  PRIMARY KEY (`id`, `placed`) NOT ENFORCED,
  WATERMARK FOR `timestamp` AS `timestamp` - INTERVAL '0.001' SECOND
) WITH (
  'format' = 'flexible-json',
  'path' = '${DATA_PATH}/sensors.jsonl',
  'connector' = 'filesystem'
)
LIKE `SensorUpdates__schema`;
CREATE VIEW `SecReading`
AS
SELECT `sensorid`, `window_time` AS `timeSec`, AVG(`temperature`) AS `temp`
FROM TABLE(TUMBLE(TABLE `SensorReading`, DESCRIPTOR(`timestamp`), INTERVAL '1' SECOND))
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`;
CREATE VIEW `Sensors`
AS
SELECT `id`, `machineId`, `placed`, `timestamp`
FROM (SELECT `id`, `machineId`, `placed`, `timestamp`, ROW_NUMBER() OVER (PARTITION BY `id` ORDER BY `timestamp` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`SensorUpdates`) AS `t`
WHERE `__sqrlinternal_rownum` = 1;
CREATE VIEW `_SensorMaxTempWindow`
AS
SELECT `sensorid`, `window_time`, AVG(`temp`) AS `avgTemp`, MAX(`temp`) AS `maxTemp`
FROM TABLE(HOP(TABLE `SecReading`, DESCRIPTOR(`timeSec`), INTERVAL '1' MINUTE, INTERVAL '60' MINUTE))
GROUP BY `sensorid`, `window_start`, `window_end`, `window_time`;
CREATE VIEW `SensorLastHour`
AS
SELECT `sensorid`, `window_time`, `avgTemp`, `maxTemp`
FROM (SELECT `sensorid`, `window_time`, `avgTemp`, `maxTemp`, ROW_NUMBER() OVER (PARTITION BY `sensorid` ORDER BY `window_time` DESC NULLS LAST) AS `__sqrlinternal_rownum`
  FROM `default_catalog`.`default_database`.`_SensorMaxTempWindow`) AS `t`
WHERE `__sqrlinternal_rownum` = 1;
CREATE VIEW `Machine`
AS
SELECT `machineId`, MAX(`temp`) AS `maxTemp`, AVG(`temp`) AS `avgTemp`
FROM `SecReading` AS `r`
 INNER JOIN `Sensors` FOR SYSTEM_TIME AS OF `r`.`timeSec` AS `s` ON `r`.`sensorid` = `s`.`id`
GROUP BY `machineId`;
CREATE VIEW `HighTemp`
AS
SELECT `machineId`, `sensorid`, `temp`, `timeSec`
FROM `SecReading` AS `r`
 INNER JOIN `Sensors` FOR SYSTEM_TIME AS OF `r`.`timeSec` AS `s` ON `r`.`sensorid` = `s`.`id`
WHERE `temp` > 35;
CREATE TABLE `HighTemp_1` (
  `machineId` BIGINT NOT NULL,
  `sensorid` BIGINT NOT NULL,
  `temp` DOUBLE NOT NULL,
  `timeSec` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`sensorid`, `timeSec`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'HighTemp',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `Machine_2` (
  `machineId` BIGINT NOT NULL,
  `maxTemp` DOUBLE NOT NULL,
  `avgTemp` DOUBLE NOT NULL,
  PRIMARY KEY (`machineId`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'Machine',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `SecReading_3` (
  `sensorid` BIGINT NOT NULL,
  `timeSec` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `temp` DOUBLE NOT NULL,
  PRIMARY KEY (`sensorid`, `timeSec`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'SecReading',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `SensorLastHour_4` (
  `sensorid` BIGINT NOT NULL,
  `window_time` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  `avgTemp` DOUBLE NOT NULL,
  `maxTemp` DOUBLE NOT NULL,
  PRIMARY KEY (`sensorid`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'SensorLastHour',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `SensorReading_5` (
  `sensorid` BIGINT NOT NULL,
  `time` BIGINT NOT NULL,
  `temperature` DOUBLE NOT NULL,
  `humidity` DOUBLE NOT NULL,
  `timestamp` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`sensorid`, `time`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'SensorReading',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `SensorUpdates_6` (
  `id` BIGINT NOT NULL,
  `machineId` BIGINT NOT NULL,
  `placed` BIGINT NOT NULL,
  `timestamp` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`id`, `placed`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'SensorUpdates',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
CREATE TABLE `Sensors_7` (
  `id` BIGINT NOT NULL,
  `machineId` BIGINT NOT NULL,
  `placed` BIGINT NOT NULL,
  `timestamp` TIMESTAMP(3) WITH LOCAL TIME ZONE NOT NULL,
  PRIMARY KEY (`id`) NOT ENFORCED
) WITH (
  'connector' = 'jdbc-sqrl',
  'driver' = 'org.postgresql.Driver',
  'password' = '${POSTGRES_PASSWORD}',
  'table-name' = 'Sensors',
  'url' = 'jdbc:postgresql://${POSTGRES_AUTHORITY}',
  'username' = '${POSTGRES_USERNAME}'
);
EXECUTE STATEMENT SET BEGIN
INSERT INTO `default_catalog`.`default_database`.`HighTemp_1`
SELECT *
 FROM `default_catalog`.`default_database`.`HighTemp`
;
INSERT INTO `default_catalog`.`default_database`.`Machine_2`
 SELECT *
  FROM `default_catalog`.`default_database`.`Machine`
 ;
 INSERT INTO `default_catalog`.`default_database`.`SecReading_3`
  SELECT *
   FROM `default_catalog`.`default_database`.`SecReading`
  ;
  INSERT INTO `default_catalog`.`default_database`.`SensorLastHour_4`
   SELECT *
    FROM `default_catalog`.`default_database`.`_SensorMaxTempWindow`
   ;
   INSERT INTO `default_catalog`.`default_database`.`SensorReading_5`
    SELECT *
     FROM `default_catalog`.`default_database`.`SensorReading`
    ;
    INSERT INTO `default_catalog`.`default_database`.`SensorUpdates_6`
     SELECT *
      FROM `default_catalog`.`default_database`.`SensorUpdates`
     ;
     INSERT INTO `default_catalog`.`default_database`.`Sensors_7`
      SELECT *
       FROM `default_catalog`.`default_database`.`SensorUpdates`
      ;
      END
>>>kafka.json
{
  "topics" : [ ],
  "testRunnerTopics" : [ ]
}
>>>postgres-schema.sql
CREATE TABLE IF NOT EXISTS "HighTemp" ("machineId" BIGINT NOT NULL, "sensorid" BIGINT NOT NULL, "temp" DOUBLE PRECISION NOT NULL, "timeSec" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("sensorid","timeSec"));
CREATE TABLE IF NOT EXISTS "Machine" ("machineId" BIGINT NOT NULL, "maxTemp" DOUBLE PRECISION NOT NULL, "avgTemp" DOUBLE PRECISION NOT NULL, PRIMARY KEY ("machineId"));
CREATE TABLE IF NOT EXISTS "SecReading" ("sensorid" BIGINT NOT NULL, "timeSec" TIMESTAMP WITH TIME ZONE NOT NULL, "temp" DOUBLE PRECISION NOT NULL, PRIMARY KEY ("sensorid","timeSec"));
CREATE TABLE IF NOT EXISTS "SensorLastHour" ("sensorid" BIGINT NOT NULL, "window_time" TIMESTAMP WITH TIME ZONE NOT NULL, "avgTemp" DOUBLE PRECISION NOT NULL, "maxTemp" DOUBLE PRECISION NOT NULL, PRIMARY KEY ("sensorid"));
CREATE TABLE IF NOT EXISTS "SensorReading" ("sensorid" BIGINT NOT NULL, "time" BIGINT NOT NULL, "temperature" DOUBLE PRECISION NOT NULL, "humidity" DOUBLE PRECISION NOT NULL, "timestamp" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("sensorid","time"));
CREATE TABLE IF NOT EXISTS "SensorUpdates" ("id" BIGINT NOT NULL, "machineId" BIGINT NOT NULL, "placed" BIGINT NOT NULL, "timestamp" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id","placed"));
CREATE TABLE IF NOT EXISTS "Sensors" ("id" BIGINT NOT NULL, "machineId" BIGINT NOT NULL, "placed" BIGINT NOT NULL, "timestamp" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));

CREATE INDEX IF NOT EXISTS "Sensors_hash_c1" ON "Sensors" USING hash ("machineId")
>>>postgres-views.sql

>>>vertx.json
{
  "models" : {
    "v1" : {
      "queries" : [
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "HighTemp",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"HighTemp\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "Machine",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Machine\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Machine",
          "fieldName" : "sensors",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Sensors\"\nWHERE \"machineId\" = $1",
              "parameters" : [
                {
                  "type" : "source",
                  "key" : "machineId"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Sensors",
          "fieldName" : "lastHour",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"SensorLastHour\"\nWHERE $1 = \"sensorid\"",
              "parameters" : [
                {
                  "type" : "source",
                  "key" : "id"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Sensors",
          "fieldName" : "readings",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM (SELECT \"sensorid\", \"timeSec\", \"temp\"\n  FROM \"SecReading\"\n  ORDER BY \"timeSec\" DESC NULLS LAST) AS \"t\"\nWHERE \"sensorid\" = $1",
              "parameters" : [
                {
                  "type" : "source",
                  "key" : "id"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "SecReading",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM (SELECT \"sensorid\", \"timeSec\", \"temp\"\n  FROM \"SecReading\"\n  ORDER BY \"timeSec\" DESC NULLS LAST) AS \"t\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "SensorLastHour",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"SensorLastHour\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "SensorReading",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"SensorReading\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "SensorUpdates",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"SensorUpdates\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "Sensors",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM \"Sensors\"",
              "parameters" : [ ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        },
        {
          "type" : "args",
          "parentType" : "Query",
          "fieldName" : "SecReadingByTemp",
          "exec" : {
            "arguments" : [
              {
                "type" : "variable",
                "path" : "limit"
              },
              {
                "type" : "variable",
                "path" : "temp"
              },
              {
                "type" : "variable",
                "path" : "offset"
              }
            ],
            "query" : {
              "type" : "SqlQuery",
              "sql" : "SELECT *\nFROM (SELECT \"sensorid\", \"timeSec\", \"temp\"\n  FROM \"SecReading\"\n  ORDER BY \"timeSec\" DESC NULLS LAST) AS \"t\"\nWHERE \"temp\" > $1\nORDER BY \"timeSec\" NULLS FIRST\nFETCH NEXT 10 ROWS ONLY",
              "parameters" : [
                {
                  "type" : "arg",
                  "path" : "temp"
                }
              ],
              "pagination" : "LIMIT_AND_OFFSET",
              "cacheDurationMs" : 0,
              "database" : "POSTGRES"
            }
          }
        }
      ],
      "mutations" : [ ],
      "subscriptions" : [ ],
      "operations" : [
        {
          "function" : {
            "name" : "GetHighTemp",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query HighTemp($limit: Int = 10, $offset: Int = 0) {\nHighTemp(limit: $limit, offset: $offset) {\nmachineId\nsensorid\ntemp\ntimeSec\n}\n\n}",
            "queryName" : "HighTemp",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/HighTemp{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetMachine",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "sensors_lastHour_offset" : {
                  "type" : "integer"
                },
                "offset" : {
                  "type" : "integer"
                },
                "sensors_readings_offset" : {
                  "type" : "integer"
                },
                "sensors_limit" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                },
                "sensors_readings_limit" : {
                  "type" : "integer"
                },
                "sensors_offset" : {
                  "type" : "integer"
                },
                "sensors_lastHour_limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query Machine($limit: Int = 10, $offset: Int = 0$sensors_limit: Int = 10, $sensors_offset: Int = 0$sensors_lastHour_limit: Int = 10, $sensors_lastHour_offset: Int = 0$sensors_readings_limit: Int = 10, $sensors_readings_offset: Int = 0) {\nMachine(limit: $limit, offset: $offset) {\nmachineId\nmaxTemp\navgTemp\nsensors(limit: $sensors_limit, offset: $sensors_offset) {\nid\nmachineId\nplaced\ntimestamp\nlastHour(limit: $sensors_lastHour_limit, offset: $sensors_lastHour_offset) {\nsensorid\nwindow_time\navgTemp\nmaxTemp\n}\nreadings(limit: $sensors_readings_limit, offset: $sensors_readings_offset) {\nsensorid\ntimeSec\ntemp\n}\n}\n}\n\n}",
            "queryName" : "Machine",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/Machine{?sensors_lastHour_offset,offset,sensors_readings_offset,sensors_limit,limit,sensors_readings_limit,sensors_offset,sensors_lastHour_limit}"
        },
        {
          "function" : {
            "name" : "GetSecReading",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query SecReading($limit: Int = 10, $offset: Int = 0) {\nSecReading(limit: $limit, offset: $offset) {\nsensorid\ntimeSec\ntemp\n}\n\n}",
            "queryName" : "SecReading",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/SecReading{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetSensorLastHour",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query SensorLastHour($limit: Int = 10, $offset: Int = 0) {\nSensorLastHour(limit: $limit, offset: $offset) {\nsensorid\nwindow_time\navgTemp\nmaxTemp\n}\n\n}",
            "queryName" : "SensorLastHour",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/SensorLastHour{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetSensorReading",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query SensorReading($limit: Int = 10, $offset: Int = 0) {\nSensorReading(limit: $limit, offset: $offset) {\nsensorid\ntime\ntemperature\nhumidity\ntimestamp\n}\n\n}",
            "queryName" : "SensorReading",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/SensorReading{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetSensorUpdates",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query SensorUpdates($limit: Int = 10, $offset: Int = 0) {\nSensorUpdates(limit: $limit, offset: $offset) {\nid\nmachineId\nplaced\ntimestamp\n}\n\n}",
            "queryName" : "SensorUpdates",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/SensorUpdates{?offset,limit}"
        },
        {
          "function" : {
            "name" : "GetSensors",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "offset" : {
                  "type" : "integer"
                },
                "readings_limit" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                },
                "readings_offset" : {
                  "type" : "integer"
                },
                "lastHour_offset" : {
                  "type" : "integer"
                },
                "lastHour_limit" : {
                  "type" : "integer"
                }
              },
              "required" : [ ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query Sensors($limit: Int = 10, $offset: Int = 0$lastHour_limit: Int = 10, $lastHour_offset: Int = 0$readings_limit: Int = 10, $readings_offset: Int = 0) {\nSensors(limit: $limit, offset: $offset) {\nid\nmachineId\nplaced\ntimestamp\nlastHour(limit: $lastHour_limit, offset: $lastHour_offset) {\nsensorid\nwindow_time\navgTemp\nmaxTemp\n}\nreadings(limit: $readings_limit, offset: $readings_offset) {\nsensorid\ntimeSec\ntemp\n}\n}\n\n}",
            "queryName" : "Sensors",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/Sensors{?offset,readings_limit,limit,readings_offset,lastHour_offset,lastHour_limit}"
        },
        {
          "function" : {
            "name" : "GetSecReadingByTemp",
            "parameters" : {
              "type" : "object",
              "properties" : {
                "temp" : {
                  "type" : "integer"
                },
                "offset" : {
                  "type" : "integer"
                },
                "limit" : {
                  "type" : "integer"
                }
              },
              "required" : [
                "temp"
              ]
            }
          },
          "format" : "JSON",
          "apiQuery" : {
            "query" : "query SecReadingByTemp($temp: Int!, $limit: Int = 10, $offset: Int = 0) {\nSecReadingByTemp(temp: $temp, limit: $limit, offset: $offset) {\nsensorid\ntimeSec\ntemp\n}\n\n}",
            "queryName" : "SecReadingByTemp",
            "operationType" : "QUERY"
          },
          "mcpMethod" : "TOOL",
          "restMethod" : "GET",
          "uriTemplate" : "queries/SecReadingByTemp{?temp,offset,limit}"
        }
      ],
      "schema" : {
        "type" : "string",
        "schema" : "\"An RFC-3339 compliant Full Date Scalar\"\nscalar Date\n\n\"A DateTime scalar that handles both full RFC3339 and shorter timestamp formats\"\nscalar DateTime\n\ntype HighTemp {\n  machineId: Long!\n  sensorid: Long!\n  temp: Float!\n  timeSec: DateTime!\n}\n\n\"A JSON scalar\"\nscalar JSON\n\n\"24-hour clock time value string in the format `hh:mm:ss` or `hh:mm:ss.sss`.\"\nscalar LocalTime\n\n\"A 64-bit signed integer\"\nscalar Long\n\ntype Machine {\n  machineId: Long!\n  maxTemp: Float!\n  avgTemp: Float!\n  sensors(limit: Int = 10, offset: Int = 0): [Sensors!]\n}\n\ntype Query {\n  HighTemp(limit: Int = 10, offset: Int = 0): [HighTemp!]\n  Machine(limit: Int = 10, offset: Int = 0): [Machine!]\n  SecReading(limit: Int = 10, offset: Int = 0): [SecReading!]\n  SensorLastHour(limit: Int = 10, offset: Int = 0): [SensorLastHour!]\n  SensorReading(limit: Int = 10, offset: Int = 0): [SensorReading!]\n  SensorUpdates(limit: Int = 10, offset: Int = 0): [SensorUpdates!]\n  Sensors(limit: Int = 10, offset: Int = 0): [Sensors!]\n  SecReadingByTemp(temp: Int!, limit: Int = 10, offset: Int = 0): [SecReading!]\n}\n\ntype SecReading {\n  sensorid: Long!\n  timeSec: DateTime!\n  temp: Float!\n}\n\ntype SensorLastHour {\n  sensorid: Long!\n  window_time: DateTime!\n  avgTemp: Float!\n  maxTemp: Float!\n}\n\ntype SensorReading {\n  sensorid: Long!\n  time: Long!\n  temperature: Float!\n  humidity: Float!\n  timestamp: DateTime!\n}\n\ntype SensorUpdates {\n  id: Long!\n  machineId: Long!\n  placed: Long!\n  timestamp: DateTime!\n}\n\ntype Sensors {\n  id: Long!\n  machineId: Long!\n  placed: Long!\n  timestamp: DateTime!\n  lastHour(limit: Int = 10, offset: Int = 0): [SensorLastHour!]\n  readings(limit: Int = 10, offset: Int = 0): [SecReading!]\n}\n\nenum _McpMethodType {\n  NONE\n  TOOL\n  RESOURCE\n}\n\nenum _RestMethodType {\n  NONE\n  GET\n  POST\n}\n\ndirective @api(mcp: _McpMethodType, rest: _RestMethodType, uri: String) on QUERY | MUTATION | FIELD_DEFINITION\n"
      }
    }
  }
}
