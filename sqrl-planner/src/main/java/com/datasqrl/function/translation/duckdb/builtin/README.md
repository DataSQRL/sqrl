| FlinkSQL signature (not identical in DuckDB 1.4.4)                                                                                                                          | DuckDB mapping                                                                                                                                                |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `AGG_DECIMAL_PLUS(<DECIMAL>, <DECIMAL>)`                                                                                                                                    | Planner-internal decimal accumulator; use `sum(x)` / `sum(y)` and `+` as needed.                                                                              |
| `ARRAY(<COMMON>, <COMMON>...)`                                                                                                                                              | List literal: `[e1, e2, ...]` (or `list_value(e1, e2, ...)`).                                                                                                 |
| `ARRAY_EXCEPT(<COMMON>, <COMMON>)`                                                                                                                                          | `list_filter(a, x -> NOT list_contains(b, x))`                                                                                                                |
| `ARRAY_JOIN(ARRAY<STRING>, <CHARACTER_STRING>)`                                                                                                                             | `array_to_string(arr, sep)`                                                                                                                                   |
| `ARRAY_JOIN(ARRAY<STRING>, <CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                         | `array_to_string(list_transform(arr, x -> coalesce(x, null_repl)), sep)`                                                                                      |
| `ARRAY_MAX(<ARRAY<COMPARABLE>>)`                                                                                                                                            | `list_max(arr)`                                                                                                                                               |
| `ARRAY_MIN(<ARRAY<COMPARABLE>>)`                                                                                                                                            | `list_min(arr)`                                                                                                                                               |
| `ARRAY_REMOVE(haystack: <ARRAY>, needle: <ARRAY ELEMENT>)`                                                                                                                  | `list_filter(haystack, x -> x <> needle)`                                                                                                                     |
| `ARRAY_SLICE(<ARRAY>, <INTEGER>)`                                                                                                                                           | `list_slice(arr, start, array_length(arr))`                                                                                                                   |
| `ARRAY_UNION(<COMMON>, <COMMON>)`                                                                                                                                           | `list_distinct(list_concat(a, b))`                                                                                                                            |
| `ASSIGNMENT(*)`                                                                                                                                                             | SQL assignment is not a DuckDB function; handle as statement syntax (planner-internal).                                                                       |
| `BTRIM(str: <CHARACTER_STRING>)`                                                                                                                                            | `trim(str)`                                                                                                                                                   |
| `BTRIM(str: <CHARACTER_STRING>, trimStr: <CHARACTER_STRING>)`                                                                                                               | `trim(str, trimStr)`                                                                                                                                          |
| `CEIL(<DATETIME>, <SYMBOL>)`                                                                                                                                                | No direct equivalent; approximate with `CASE WHEN dt=date_trunc('unit',dt) THEN dt ELSE date_trunc('unit',dt)+INTERVAL '1 unit' END` (unit must be constant). |
| `CEIL(<INTERVAL>)`                                                                                                                                                          | No equivalent; requires custom UDF.                                                                                                                           |
| `COLLECT(<ANY>)`                                                                                                                                                            | `list(x)` / `array_agg(x)`                                                                                                                                    |
| `CONVERT_TZ(<CHARACTER_STRING>, <CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                    | `timezone(to_tz, timezone(from_tz, cast(ts_str as timestamp)))`                                                                                               |
| `CURRENTDATABASE(*)`                                                                                                                                                        | `current_database()`                                                                                                                                          |
| `CURRENT_ROW_TIMESTAMP(*)`                                                                                                                                                  | `current_timestamp`                                                                                                                                           |
| `CURRENT_WATERMARK(<TIMESTAMP_WITHOUT_TIME_ZONE *ROWTIME*>)`                                                                                                                | Not supported in DuckDB (streaming watermark); use `NULL` or drop.                                                                                            |
| `CURRENT_WATERMARK(<TIMESTAMP_WITH_LOCAL_TIME_ZONE *ROWTIME*>)`                                                                                                             | Not supported in DuckDB (streaming watermark); use `NULL` or drop.                                                                                            |
| `DATE_FORMAT(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                       | `strftime(try_cast(ts_str as timestamp), fmt)`                                                                                                                |
| `DATE_FORMAT(<TIMESTAMP>, <CHARACTER_STRING>)`                                                                                                                              | `strftime(ts, fmt)`                                                                                                                                           |
| `DECODE(<BINARY_STRING>, <CHARACTER_STRING>)`                                                                                                                               | No charset-aware decode; for UTF-8: `cast(blob as varchar)`; for Base64: `cast(from_base64(str) as varchar)` (if input is Base64 text).                       |
| `E()`                                                                                                                                                                       | `exp(1)`                                                                                                                                                      |
| `ELEMENT(<ARRAY>)`                                                                                                                                                          | DuckDB has no `ELEMENT`; use `list_/extract(arr, 1)` and ensure `array_length(arr)=1`.                                                                        |
| `ELT(index: <INTEGER_NUMERIC>, expr: <BINARY_STRING>, exprs: <BINARY_STRING>...)`                                                                                           | `list_extract([expr, exprs...], index)`                                                                                                                       |
| `ELT(index: <INTEGER_NUMERIC>, expr: <CHARACTER_STRING>, exprs: <CHARACTER_STRING>...)`                                                                                     | `list_extract([expr, exprs...], index)`                                                                                                                       |
| `ENCODE(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                            | No charset-aware encode; for UTF-8 bytes: `cast(str as blob)` (other encodings require UDF).                                                                  |
| `ENDSWITH(expr: <BINARY_STRING>, endExpr: <BINARY_STRING>)`                                                                                                                 | For blobs: `right(expr, octet_length(endExpr)) = endExpr`                                                                                                     |
| `ENDSWITH(expr: <CHARACTER_STRING>, endExpr: <CHARACTER_STRING>)`                                                                                                           | `ends_with(expr, endExpr)`                                                                                                                                    |
| `FLOOR(<DATETIME>, <SYMBOL>)`                                                                                                                                               | `date_trunc('unit', dt)` (unit must be constant).                                                                                                             |
| `FLOOR(<INTERVAL>)`                                                                                                                                                         | No equivalent; requires custom UDF.                                                                                                                           |
| `FROM_UNIXTIME(<NUMERIC>)`                                                                                                                                                  | `strftime(to_timestamp(epoch_seconds), '%Y-%m-%d %H:%M:%S')`                                                                                                  |
| `FROM_UNIXTIME(<NUMERIC>, <CHARACTER_STRING>)`                                                                                                                              | `strftime(to_timestamp(epoch_seconds), fmt)`                                                                                                                  |
| `IFTHENELSE(<BOOLEAN>, <COMMON>, <COMMON>)`                                                                                                                                 | `if(cond, then_val, else_val)` (or `CASE WHEN cond THEN then_val ELSE else_val END`).                                                                         |
| `INITCAP(<CHARACTER_STRING>)`                                                                                                                                               | No built-in; requires custom UDF.                                                                                                                             |
| `IS_JSON(<CHARACTER_STRING>)`                                                                                                                                               | `json_valid(str)`                                                                                                                                             |
| `IS_JSON(<CHARACTER_STRING>, <JsonType>)`                                                                                                                                   | `json_valid(str) AND json_type(json(str)) = '<expected>'` (type check optional).                                                                              |
| `JSON_ARRAYAGG([<CHARACTER_STRING>                                                                                                                                          | <BINARY_STRING>                                                                                                                                               | <TIMESTAMP> | <CONSTRUCTED> | <NUMERIC> | <STRUCTURED_TYPE> | <DISTINCT_TYPE> | <BOOLEAN>])` | `json_group_array(value)` |
| `JSON_EXISTS(<CHARACTER_STRING>, [<CHARACTER_STRING> & <LITERAL NOT NULL>], <JsonExistsOnError>)`                                                                           | DuckDB only supports `json_exists(json, path)`; ignore `on_error`.                                                                                            |
| `JSON_OBJECTAGG(<CHARACTER_STRING>, [<CHARACTER_STRING>                                                                                                                     | <BINARY_STRING>                                                                                                                                               | <TIMESTAMP> | <CONSTRUCTED> | <NUMERIC> | <STRUCTURED_TYPE> | <DISTINCT_TYPE> | <BOOLEAN>])` | `json_group_object(key, value)` |
| `JSON_QUERY(<CHARACTER_STRING>, [<CHARACTER_STRING> & <LITERAL NOT NULL>], <DATA TYPE NOT NULL>, <JsonQueryWrapper>, <JsonQueryOnEmptyOrError>, <JsonQueryOnEmptyOrError>)` | `json_extract(json, path)`; wrapper/return-type/on-empty/on-error options require custom rewrite/UDF.                                                         |
| `JSON_STRING([<CHARACTER_STRING>                                                                                                                                            | <BINARY_STRING>                                                                                                                                               | <TIMESTAMP> | <CONSTRUCTED> | <NUMERIC> | <STRUCTURED_TYPE> | <DISTINCT_TYPE> | <BOOLEAN>])` | `to_json(value)` (or `json_quote(str)` for quoting strings). |
| `JSON_UNQUOTE(<CHARACTER_STRING>)`                                                                                                                                          | `json_extract_string(json(str), '$')`                                                                                                                         |
| `JSON_VALUE(<CHARACTER_STRING>, [<CHARACTER_STRING> & <LITERAL NOT NULL>], <DATA TYPE NOT NULL>, <JsonValueOnEmptyOrError>, <ANY>, <JsonValueOnEmptyOrError>, <ANY>)`       | `try_cast(json_value(json, path) AS <type>)`; on-empty/on-error behaviors not fully supported.                                                                |
| `LOCATE(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                            | `instr(str, substr)` (note argument order swap).                                                                                                              |
| `LOCATE(<CHARACTER_STRING>, <CHARACTER_STRING>, <INTEGER_NUMERIC>)`                                                                                                         | `CASE WHEN instr(substr(str, start), substr)=0 THEN 0 ELSE instr(substr(str, start), substr)+start-1 END`                                                     |
| `LOWERCASE(<CHARACTER_STRING>)`                                                                                                                                             | `lower(str)`                                                                                                                                                  |
| `MAP(*)`                                                                                                                                                                    | Build keys/values lists: `map([k1, k2, ...], [v1, v2, ...])`                                                                                                  |
| `MAP_FROM_ARRAYS(keysArray: <ARRAY>, valuesArray: <ARRAY>)`                                                                                                                 | `map(keysArray, valuesArray)`                                                                                                                                 |
| `MAP_UNION(<COMMON>, <COMMON>...)`                                                                                                                                          | `map_concat(map1, map2, ...)`                                                                                                                                 |
| `ML_PREDICT(TABLE: ROW, MODEL: MODEL, ARGS: DESCRIPTOR)`                                                                                                                    | No DuckDB equivalent; requires ML extension/UDF.                                                                                                              |
| `ML_PREDICT(TABLE: ROW, MODEL: MODEL, ARGS: DESCRIPTOR, CONFIG: MAP)`                                                                                                       | No DuckDB equivalent; requires ML extension/UDF.                                                                                                              |
| `OBJECT_OF(class name: STRING, [STRING, ANY]*...)`                                                                                                                          | For JSON objects: `json_object(k1, v1, k2, v2, ...)` (class name ignored).                                                                                    |
| `OBJECT_UPDATE(object: STRUCTURED_TYPE, [STRING, ANY]+...)`                                                                                                                 | For JSON: `json_merge_patch(obj, json_object(k1, v1, ...))` (struct updates with dynamic keys require UDF).                                                   |
| `OVERLAY(<CHARACTER_STRING>, <CHARACTER_STRING>, <INTEGER>)`                                                                                                                | `substr(str,1,start-1)                                                                                                                                        || repl || substr(str,start+length(repl))` |
| `OVERLAY(<CHARACTER_STRING>, <CHARACTER_STRING>, <INTEGER>, <INTEGER>)`                                                                                                     | `substr(str,1,start-1)                                                                                                                                        || repl || substr(str,start+len)` |
| `PARSE_JSON(<CHARACTER_STRING>)`                                                                                                                                            | `cast(str as json)` (or `json(str)`).                                                                                                                         |
| `PARSE_JSON(<CHARACTER_STRING>, <BOOLEAN>)`                                                                                                                                 | If flag = fail_on_error: `CASE WHEN flag THEN cast(str as json) ELSE try_cast(str as json) END`                                                               |
| `PARSE_URL(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                         | No built-in URL component extraction; requires custom UDF.                                                                                                    |
| `PARSE_URL(<CHARACTER_STRING>, <CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                     | No built-in URL component extraction; requires custom UDF.                                                                                                    |
| `RAND()`                                                                                                                                                                    | `random()`                                                                                                                                                    |
| `RAND(<INTEGER>)`                                                                                                                                                           | DuckDB `random()` has no seed; use `random()` (seed ignored) or deterministic `hash(seed)`-based expression.                                                  |
| `RAND_INTEGER(<INTEGER>)`                                                                                                                                                   | `cast(floor(random() * max) as bigint)`                                                                                                                       |
| `RAND_INTEGER(<INTEGER>, <INTEGER>)`                                                                                                                                        | `cast(floor(random() * (max-min+1)) + min as bigint)`                                                                                                         |
| `RANGETO(*)`                                                                                                                                                                | Use DuckDB table function `range(start, stop, step)` / `generate_series(...)` (planner-internal wrapper).                                                     |
| `REGEXP(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                            | `regexp_matches(str, pattern)`                                                                                                                                |
| `REGEXP_COUNT(str: <CHARACTER_STRING>, regex: <CHARACTER_STRING>)`                                                                                                          | `array_length(regexp_extract_all(str, regex))`                                                                                                                |
| `REGEXP_INSTR(str: <CHARACTER_STRING>, regex: <CHARACTER_STRING>)`                                                                                                          | `CASE WHEN regexp_extract(str, regex, 0) IS NULL THEN 0 ELSE instr(str, regexp_extract(str, regex, 0)) END`                                                   |
| `REGEXP_SUBSTR(str: <CHARACTER_STRING>, regex: <CHARACTER_STRING>)`                                                                                                         | `regexp_extract(str, regex, 0)`                                                                                                                               |
| `ROWTIME(<WINDOW REFERENCE>)`                                                                                                                                               | Not supported (Flink event-time attribute); requires explicit timestamp columns.                                                                              |
| `SHA2(<CHARACTER_STRING>, <INTEGER>)`                                                                                                                                       | `CASE WHEN bitlen=256 THEN sha256(str) WHEN bitlen=1 THEN sha1(str) ELSE NULL END` (only `sha1`/`sha256` built-in).                                           |
| `SPLIT_INDEX(<CHARACTER_STRING>, <CHARACTER_STRING>, <INTEGER>)`                                                                                                            | Flink index is 0-based: `split_part(str, delim, idx + 1)`                                                                                                     |
| `STARTSWITH(expr: <BINARY_STRING>, startExpr: <BINARY_STRING>)`                                                                                                             | For blobs: `left(expr, octet_length(startExpr)) = startExpr`                                                                                                  |
| `STARTSWITH(expr: <CHARACTER_STRING>, startExpr: <CHARACTER_STRING>)`                                                                                                       | `starts_with(expr, startExpr)`                                                                                                                                |
| `STREAMRECORDTIMESTAMP()`                                                                                                                                                   | Not supported (stream record timestamp); requires explicit timestamp columns.                                                                                 |
| `STR_TO_MAP(<CHARACTER_STRING>)`                                                                                                                                            | `map(list_transform(str_split(str, ','), e -> split_part(e, '=', 1)), list_transform(str_split(str, ','), e -> split_part(e, '=', 2)))`                       |
| `STR_TO_MAP(<CHARACTER_STRING>, <CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                    | `map(list_transform(str_split(str, entryDelim), e -> split_part(e, kvDelim, 1)), list_transform(str_split(str, entryDelim), e -> split_part(e, kvDelim, 2)))` |
| `SUM0(<NUMERIC>)`                                                                                                                                                           | `coalesce(sum(x), 0)`                                                                                                                                         |
| `TEMPORALOVERLAPS(leftTimePoint: <DATETIME>, leftTemporal: <TEMPORAL>, rightTimePoint: <DATETIME>, rightTemporal: <TEMPORAL>)`                                              | `left_tp < right_tp + right_temporal AND right_tp < left_tp + left_temporal`                                                                                  |
| `TIMESTAMPDIFF(<TimePointUnit>, <DATETIME>, <DATETIME>)`                                                                                                                    | `date_diff('unit', t1, t2)` (unit must be a constant string like `'day'`).                                                                                    |
| `TO_DATE(<CHARACTER_STRING>)`                                                                                                                                               | `try_cast(str as date)` (ISO) or `cast(strptime(str, '%Y-%m-%d') as date)`                                                                                    |
| `TO_DATE(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                           | `cast(strptime(str, fmt) as date)`                                                                                                                            |
| `TO_TIMESTAMP(<CHARACTER_STRING>)`                                                                                                                                          | `try_cast(str as timestamp)` (ISO) or `strptime(str, '%Y-%m-%d %H:%M:%S')`                                                                                    |
| `TO_TIMESTAMP(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                      | `strptime(str, fmt)`                                                                                                                                          |
| `TO_TIMESTAMP_LTZ(<CHARACTER_STRING>)`                                                                                                                                      | `timezone('UTC', try_cast(str as timestamp))` (pick desired timezone explicitly).                                                                             |
| `TO_TIMESTAMP_LTZ(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                  | `timezone('UTC', strptime(str, fmt))`                                                                                                                         |
| `TO_TIMESTAMP_LTZ(<CHARACTER_STRING>, <CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                              | `timezone(tz, strptime(str, fmt))`                                                                                                                            |
| `TO_TIMESTAMP_LTZ(<NUMERIC>)`                                                                                                                                               | `to_timestamp(epoch_seconds)`                                                                                                                                 |
| `TO_TIMESTAMP_LTZ(<NUMERIC>, <INTEGER_NUMERIC>)`                                                                                                                            | `to_timestamp(epoch / pow(10, precision))` (precision-dependent scaling).                                                                                     |
| `TRUNCATE(<NUMERIC>)`                                                                                                                                                       | `trunc(x)`                                                                                                                                                    |
| `TRUNCATE(<NUMERIC>, <INTEGER>)`                                                                                                                                            | `trunc(x, scale)`                                                                                                                                             |
| `TRY_PARSE_JSON(<CHARACTER_STRING>)`                                                                                                                                        | `try_cast(str as json)`                                                                                                                                       |
| `TRY_PARSE_JSON(<CHARACTER_STRING>, <BOOLEAN>)`                                                                                                                             | `try_cast(str as json)` (flag ignored; DuckDB has no equivalent option).                                                                                      |
| `TYPEOF(input: <ANY>, force_serializable: [<BOOLEAN> & <LITERAL NOT NULL>])`                                                                                                | `typeof(input)` (DuckDB has no `force_serializable` argument).                                                                                                |
| `UNIX_TIMESTAMP()`                                                                                                                                                          | `epoch(current_timestamp)`                                                                                                                                    |
| `UNIX_TIMESTAMP(<CHARACTER_STRING>)`                                                                                                                                        | `epoch(try_cast(str as timestamp))`                                                                                                                           |
| `UNIX_TIMESTAMP(<CHARACTER_STRING>, <CHARACTER_STRING>)`                                                                                                                    | `epoch(strptime(str, fmt))`                                                                                                                                   |
| `UPPERCASE(<CHARACTER_STRING>)`                                                                                                                                             | `upper(str)`                                                                                                                                                  |
