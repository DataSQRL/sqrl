>>>Script
IMPORT mysourcepackage.Events AS ConferenceEvents TIMESTAMP last_updated AS timestamp;
IMPORT mysourcepackage.AuthTokens;
IMPORT mysourcepackage.EmailTemplates

IMPORT myAPI.Likes;
IMPORT myAPI.AddInterest;

IMPORT string.*;
IMPORT text.*;
IMPORT secure.randomID;

/* requires string aggregated concatenation
ConferenceEvents.speakerSummary := SELECT concatAgg( s.name + '(' + s.title + ' at ' + s.company + ')', ', ') as name
                                 FROM @.speakers s;
 */
/* Replace with above */
ConferenceEvents.speakerSummary := SELECT CONCAT('speakerlength', (sum(length(s.name) + length(s.title) + length(s.company)))) as name
                                   FROM @.speakers s;

ConferenceEventsFlat := SELECT e._uuid, e.timestamp, e.id, e.time, e.title, e.description, e.location, s.name as name
                        FROM ConferenceEvents e JOIN e.speakerSummary s;

Events := SELECT * FROM ConferenceEventsFlat;

--Events.embedding := embed_text(title + description);
Events.embedding := length(description); -- replace by vector embedding

Events := DISTINCT Events ON id ORDER BY timestamp DESC;

--Interests.embedding := embed_text(text);
AddInterest.embedding := length(text); -- replace by vector embedding

UserInterests := SELECT userid, avg(embedding) as interestVector FROM AddInterest GROUP BY userid;

UserLikes := DISTINCT Likes ON userid, eventId ORDER BY _source_time DESC;


EventLikeCount := SELECT eventid, sum(liked) as num FROM UserLikes l GROUP BY eventid;
Events.likeCount := JOIN EventLikeCount l ON @.id = l.eventid;

EventsAfterTime(@afterTime: DateTime) := SELECT * FROM Events WHERE time > @afterTime
                                                             ORDER BY time ASC;

EventSearch(@query: String, @afterTime: DateTime) := SELECT * FROM Events WHERE
                        time >= @afterTime AND textsearch(@query, title, description) > 0
                        ORDER BY textsearch(@query, title, description) DESC;

-- Events that the user liked or that are similar to users interests (requires vector search)

PersonalizedEvents(@userid: String, @tolerance: Float, @afterTime: DateTime) :=
SELECT e.*, l.liked,
       coalesce(l.eventId, '') as shouldRemove1,
       i.interestVector / e.embedding as score
--       cosineSimilarity(i.interestVector, e.embedding) as score
FROM Events e
    LEFT JOIN UserLikes l ON e.id = l.eventId AND l.userid = @userid
    LEFT JOIN UserInterests i ON i.userid = @userid
    WHERE e.time > @afterTime
          AND (l.liked = 1 OR (i.interestVector IS NOT NULL AND
                               i.interestVector / CAST(e.embedding AS float) >= @tolerance))
--                               cosineSimilarity(i.interestVector, e.embedding) >= @tolerance))
    ORDER BY e.time ASC

--PersonalizedEvents.likeCount := JOIN EventLikeCount l ON @.id = l.eventid;

>>>Schema
scalar DateTime

type Query {
    PersonalizedEvents( userid: String!, tolerance: Float!, afterTime: DateTime!): [PersonalizedEvents!]
    EventsAfterTime(afterTime: DateTime!): [Events!]!
    EventSearch( query: String!, afterTime: DateTime!): [EventSearchResult!]!
}

interface AbstractEvents {
    id : Int!
    time : String!
    location: String!
    title : String!
    description : String!
    name : String!
}

type LikeCount {
    num : Int
}

type EventSearchResult {
    id : Int!
    time : String!
    location: String!
    title : String!
    description : String!
    name : String!
}
type Events implements AbstractEvents{
    id : Int!
    time : String!
    location: String!
    title : String!
    description : String!
    name : String!
}

type PersonalizedEvents implements AbstractEvents{
    id : Int!
    time : String!
    location: String!
    title : String!
    description : String!
    name : String!
    liked: Int!
    score: Float!
}



type Mutation {
    EventUpdate(event: EventUpdate!): EventUpdated
    Likes(liked: LikedInput!): CreatedLiked
    ReportEvent(report: EventReport!): EventReported
    AddInterest(interest: AddInterest!): InterestAdded
    EventRemoval(removal: EventRemoval!): EventRemoved
}

input EventUpdate {
    userid: String!
    id: String!
    name: String!
    email: String!
    location: String!
    time: DateTime!
    title: String!
    description: String!
    secret: String!
}

type EventUpdated {
    _source_time: String!
    userid: String!
}

input EventRemoval {
    eventId: String!
    auth_token: String!
}

type EventRemoved {
    _source_time: String!
}

input AddInterest {
    text: String!
    userid: String!
}

type InterestAdded {
    _source_time: String!
    userid: String!
}

input EventReport {
    eventId: String!
    userid: String!
}

type EventReported {
    _source_time: String!
    userid: String!
}

input LikedInput {
    eventId: String!
    userid: String!
    liked: Int!
}

type CreatedLiked {
    _source_time: String!
    userid: String!
}

>>>DDL


CREATE TABLE IF NOT EXISTS events$38 (id$0 BIGINT NOT NULL,_uuid$0 VARCHAR NOT NULL,timestamp$0 TIMESTAMPTZ NOT NULL,time$0 TIMESTAMPTZ NOT NULL,title$0 VARCHAR NOT NULL,description$0 VARCHAR NOT NULL,location$0 VARCHAR NOT NULL,name$0 VARCHAR NOT NULL,embedding$0 BIGINT NOT NULL , PRIMARY KEY (id$0));
CREATE TABLE IF NOT EXISTS userinterests$41 (userid$0 VARCHAR NOT NULL,interestvector$0 BIGINT NOT NULL,_source_time$0 TIMESTAMPTZ NOT NULL , PRIMARY KEY (userid$0));
CREATE TABLE IF NOT EXISTS userlikes$44 (userid$0 VARCHAR NOT NULL,eventid$0 VARCHAR NOT NULL,_uuid$0 VARCHAR NOT NULL,_ingest_time$0 TIMESTAMPTZ NOT NULL,_source_time$0 TIMESTAMPTZ NOT NULL,liked$0 BIGINT NOT NULL , PRIMARY KEY (userid$0,eventid$0));
CREATE INDEX IF NOT EXISTS events$38_btree_c3 ON events$38 USING btree (time$0);
CREATE INDEX IF NOT EXISTS events$38_text_c4c5 ON events$38 USING GIN (to_tsvector('english', coalesce(title$0, '') || ' ' || coalesce(description$0, '') ));
Query:PersonalizedEvents(userid, tolerance, afterTime)  =  SELECT "id$0", COALESCE("eventid$0", '') AS "shouldRemove1", "_uuid$0", "timestamp$0", "time$0", "title$0", "description$0", "location$0", "name$0", "embedding$0", "liked$0" AS "liked", "interestvector$0" / "embedding$0" AS "score", "__timestamp20"
FROM (SELECT "t1"."id$0", "t1"."_uuid$0", "t1"."timestamp$0", "t1"."time$0", "t1"."title$0", "t1"."description$0", "t1"."location$0", "t1"."name$0", "t1"."embedding$0", "t1"."userid$0", "t1"."eventid$0", "t1"."_uuid$00", "t1"."_ingest_time$0", "t1"."_source_time$0", "t1"."liked$0", "t1"."eventid$00", "t1"."__timestamp", "t2"."userid$0" AS "userid$00", "t2"."interestvector$0", "t2"."_source_time$0" AS "_source_time$00", CASE WHEN "t1"."__timestamp" < "t2"."_source_time$0" THEN "t2"."_source_time$0" ELSE "t1"."__timestamp" END AS "__timestamp20"
  FROM (SELECT *
    FROM (SELECT "events$38"."id$0", "events$38"."_uuid$0", "events$38"."timestamp$0", "events$38"."time$0", "events$38"."title$0", "events$38"."description$0", "events$38"."location$0", "events$38"."name$0", "events$38"."embedding$0", "t"."userid$0", "t"."eventid$0", "t"."_uuid$0" AS "_uuid$00", "t"."_ingest_time$0", "t"."_source_time$0", "t"."liked$0", "t"."eventid$00", CASE WHEN "events$38"."timestamp$0" < "t"."_source_time$0" THEN "t"."_source_time$0" ELSE "events$38"."timestamp$0" END AS "__timestamp"
      FROM "events$38"
       LEFT JOIN (SELECT "userid$0", "eventid$0", "_uuid$0", "_ingest_time$0", "_source_time$0", "liked$0", CAST("eventid$0" AS BIGINT) AS "eventid$00"
        FROM "userlikes$44") AS "t" ON "events$38"."id$0" = "t"."eventid$00" AND "t"."userid$0" = $1) AS "t0"
    WHERE "t0"."time$0" > $3) AS "t1"
   LEFT JOIN (SELECT *
    FROM "userinterests$41"
    WHERE "userid$0" = $1) AS "t2" ON TRUE) AS "t3"
WHERE "t3"."liked$0" = 1 OR "t3"."interestvector$0" / CAST("t3"."embedding$0" AS FLOAT) >= $2
ORDER BY "time$0", "id$0", COALESCE("eventid$0", '')

Query:EventsAfterTime(afterTime)  =  SELECT *
FROM "events$38"
WHERE "time$0" > $1
ORDER BY "time$0", "id$0"

Query:EventSearch(query, afterTime)  =  SELECT *
FROM "events$38"
WHERE "time$0" >= $2 AND (TO_TSVECTOR("title$0") @@ TO_TSQUERY(CAST($1 AS VARCHAR(65536))) AND TS_RANK_CD("title$0", CAST($1 AS VARCHAR(65536))) > 0)
ORDER BY "id$0"

>>>Queries


query$1 = SELECT `$cor3`.`_uuid$0` AS `___uuid$0$pk$1`, CHAR_LENGTH(`t20`.`name$0`) + CHAR_LENGTH(`t20`.`title$0`) + CHAR_LENGTH(`t20`.`company$0`) AS `$f1`, `t20`.`_idx$0`, `$cor3`.`timestamp$0`
FROM (SELECT `_uuid$0`, `_ingest_time$0`, `id$0`, `last_updated$0`, `time$0`, `title$0`, `location$0`, `speakers$0`, `description$0`, `timestamp$0`
  FROM `conferenceevents$i$1`) AS `$cor3`,
 UNNEST(`$cor3`.`speakers$0`) AS `t20`

root$2 = SELECT `t`.`id$0`, `t`.`_uuid$0`, `t`.`timestamp$0`, `t`.`time$0`, `t`.`title$0`, `t`.`description$0`, `t`.`location$0`, `t7`.`name` AS `name$0`, CHAR_LENGTH(`t`.`description$0`) AS `embedding$0`
FROM (SELECT `_uuid$0`, `_ingest_time$0`, `id$0`, `last_updated$0`, `time$0`, `title$0`, `location$0`, `speakers$0`, `description$0`, `timestamp$0`
  FROM `conferenceevents$i$1`) AS `t`
 INNER JOIN (SELECT `___uuid$0$pk$1`, CONCAT('speakerlength', SUM(`$f1`)) AS `name`, `window_time` AS `timestamp$0`
  FROM TABLE(TUMBLE(TABLE `query$1`, DESCRIPTOR(`timestamp$0`), INTERVAL '0.001' SECOND(1))) AS `t4`
  GROUP BY `___uuid$0$pk$1`, `window_start`, `window_end`, `window_time`) AS `t7` ON `t`.`_uuid$0` = `t7`.`___uuid$0$pk$1` AND `t`.`timestamp$0` = `t7`.`timestamp$0`

root$3 = SELECT `userid$0`, AVG(`embedding$0`) OVER (PARTITION BY `userid$0` ORDER BY `_source_time$0` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `interestvector$0`, `_source_time$0`
FROM (SELECT `_uuid$0`, `_ingest_time$0`, `_source_time$0`, `text$0`, `userid$0`, CHAR_LENGTH(`text$0`) AS `embedding$0`
  FROM `addinterest$i$22`) AS `t12`

root$4 = SELECT `userid$0`, `eventid$0`, `_uuid$0`, `_ingest_time$0`, `_source_time$0`, `liked$0`
FROM `likes$i$18`

