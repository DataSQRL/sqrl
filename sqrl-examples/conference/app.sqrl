IMPORT mysourcepackage.Events AS ConferenceEvents TIMESTAMP last_updated AS timestamp;
IMPORT mysourcepackage.AuthTokens;
IMPORT mysourcepackage.EmailTemplates

IMPORT myAPI.EventUpdate TIMESTAMP _source_time AS timestamp;
IMPORT myAPI.Likes;
IMPORT myAPI.ReportEvent;
IMPORT myAPI.AddInterest;
IMPORT myAPI.EventRemoval;

IMPORT string.*;
IMPORT text.*;
IMPORT secure.randomID;

EmailTemplates := DISTINCT EmailTemplates ON id ORDER BY last_updated DESC;
EmailTemplates := DISTINCT AuthTokens ON id ORDER BY last_updated DESC;

EventPosts := SELECT * FROM EventUpdate WHERE id IS NULL;

EventPosts.id := randomID(12);
EventPosts.secret := randomID(10);

EventPostEmail := SELECT email as toEmail, t.fromEmail, t.title,
                         format(t.textBody, name, id, secret) as textBody
                  FROM EventPosts e TEMPORAL JOIN EmailTemplates t ON t.id = 'confirmpost';

EXPORT EventPostEmail TO print.eventpostemail; --sink to queue and email sending

EventSecrets := DISTINCT EventPosts ON id ORDER BY timestamp DESC;

VerifiedEventUpdate := SELECT u.* FROM EventUpdate u TEMPORAL JOIN EventSecrets s ON u.id = s.id AND u.secret = s.secret;

AuthorizedEventRemoval := SELECT r.* FROM EventRemoval r TEMPORAL JOIN AuthTokens a ON a.id == 'removal' AND a.value = r.auth_token;

FilteredEventUpdate := SELECT v.*, ((IS NOT NULL r._uuid) OR !bannedWordsFilter(v.name)
                            OR !bannedWordsFilter(v.description) OR !bannedWordsFilter(v.location)) AS removed
                       FROM VerifiedEventUpdate v LEFT JOIN AuthorizedEventRemoval r ON v.eventId = r.eventId AND v.timestamp < r._source_time;

/* requires string aggregated concatenation */
ConferenceEvents.speakerSummary := SELECT concatAgg( s.name || '(' || s.title || ' at ' s.company || ')', ', ') as name
                                 FROM @.speakers s;
/*
ConferenceEvents.speakerSummary := SELECT 'speakerlength' || sum(length(s.name) + length(s.title) + length(s.company)) as name
                                   FROM @.speakers s;
 */
ConferenceEventsFlat := SELECT id, timestamp, time, title, description, location, speakerSummary.name as name
                        FROM ConferenceEvents;

Events := (SELECT _uuid, timestamp, id, time, title, description, name, location, removed FROM FilteredEventUpdate)
            UNION ALL
          (SELECT _uuid, timestamp, id, time, title, description, name, location, FALSE as removed FROM ConferenceEventsFlat);

EventNotification := SELECT * FROM FilteredEventUpdate WHERE NOT removed;

Events.embedding := embed_text(title || description);
--Events.embedding := length(description); -- replace by vector embedding

Events := DISTINCT Events ON id ORDER BY timestamp DESC;

Interests.embedding := embed_text(text);
--Interests.embedding := length(text); -- replace by vector embedding

UserInterests := SELECT userid, avg(embedding) as interestVector FROM Interests GROUP BY userid;

UserLikes := DISTINCT Likes ON userid, eventId ORDER BY _source_time DESC;


EventLikeCount := SELECT eventid, sum(liked) as num FROM UserLikes l GROUP BY eventid;
Events.likeCount := JOIN EventLikeCount l ON @.id = l.eventid;

EventsAfterTime(afterTime: DateTime) := SELECT * FROM Events WHERE startTime > :afterTime AND NOT removed
                                                             ORDER BY startTime ASC;

EventSearch( query: String, afterTime: DateTime) := SELECT * FROM Events WHERE
                        startTime > :afterTime AND textsearch(query, title, description)
                        AND NOT removed
                        ORDER BY textsearch(query, title, description) DESC;

-- Events that the user liked or that are similar to users interests (requires vector search)

PersonalizedEvents( userid: String, tolerance: Float, afterTime: DateTime) :=
SELECT e.*, l.liked, cosineSimilarity(i.interestVector, e.embedding) as score FROM Events e
    LEFT JOIN UserLikes l ON e.id = l.eventId AND e.userid = :userid
    LEFT JOIN UserInterests i ON i.userid = :userid
    WHERE e.startTime > :afterTime AND NOT removed
          AND (l.liked = 1 OR (i.interestVector NOT NULL AND cosineSimilarity(i.interestVector, e.embedding) >= tolerance)
    ORDER BY e.startTime ASC

PersonalizedEvents.likeCount := JOIN EventLikes l ON @.id = l.eventId;
/**/


FlaggedEventEmail := SELECT t.toEmail, t.fromEmail, t.title,
                         format(t.textBody, r.eventid, e.title, e.description, e.name) as textBody
                  FROM ReportEvent r
                  TEMPORAL JOIN Events e ON r.eventid = e.id
                  TEMPORAL JOIN EmailTemplates t ON t.id = 'eventflag';

EXPORT FlaggedEventEmail TO print.flaggedEventEmail;