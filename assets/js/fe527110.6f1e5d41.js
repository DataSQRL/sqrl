"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8274],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},9776:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"howto/testing-authorization","title":"Testing Authorization","description":"You can test record filtering, data masking, and other types of authorization based data access control with DataSQRL\'s automated test runner via the test command.","source":"@site/docs/howto/testing-authorization.md","sourceDirName":"howto","slug":"/howto/testing-authorization","permalink":"/docs/howto/testing-authorization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Templating","permalink":"/docs/howto/templating"},"next":{"title":"Testing","permalink":"/docs/howto/testing"}}');var i=n(4848),o=n(8453);const r={},a="Testing Authorization",c={},d=[{value:"Generating Tokens",id:"generating-tokens",level:2},{value:"Default Test Runner Token",id:"default-test-runner-token",level:2},{value:"Additional Tests",id:"additional-tests",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"testing-authorization",children:"Testing Authorization"})}),"\n",(0,i.jsxs)(t.p,{children:["You can test record filtering, data masking, and other types of authorization based data access control with DataSQRL's automated test runner via the ",(0,i.jsxs)(t.a,{href:"../compiler#test-command",children:[(0,i.jsx)(t.code,{children:"test"})," command"]}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"generating-tokens",children:"Generating Tokens"}),"\n",(0,i.jsxs)(t.p,{children:["To generate test tokens, one of the most straightforward ways would be to use the ",(0,i.jsx)(t.strong,{children:"JWT Encoder"})," functionality of ",(0,i.jsx)(t.a,{href:"https://jwt.io",children:"https://jwt.io"}),".\nThe ",(0,i.jsx)(t.strong,{children:"Payload: Data"})," can be shaped to our testing needs.\nFor testing purposes, using the ",(0,i.jsx)(t.code,{children:"HS256"})," algorithm probably should be completely fine.\nThen, we only need to define a long enough signer secret string on the website."]}),"\n",(0,i.jsxs)(t.p,{children:["The only manual step that is required in case of ",(0,i.jsx)(t.code,{children:"HS265"})," is to apply Base64 encoding to your given secret, for example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"echo -n mySuperSecretSignerStringThatIsLongEnough | base64\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And then we need to set the encoded secret as the ",(0,i.jsx)(t.code,{children:"buffer"})," in the ",(0,i.jsx)(t.code,{children:"package.json"})," file ",(0,i.jsx)(t.code,{children:"vertx"})," config section:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n  ...\n  "engines" : {\n    "vertx" : {\n      "authKind": "JWT",\n      "config": {\n        "jwtAuth": {\n          "pubSecKeys": [\n            {\n              "algorithm": "HS256",\n              "buffer": "bXlTdXBlclNlY3JldFNpZ25lclN0cmluZ1RoYXRJc0xvbmdFbm91Z2gK"\n            }\n          ],\n          ...\n        }\n      }\n    }\n  },\n  ...\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"default-test-runner-token",children:"Default Test Runner Token"}),"\n",(0,i.jsxs)(t.p,{children:["We can set one token directly to the ",(0,i.jsx)(t.code,{children:"test-runner"})," configuration that the deployed test server will pick up by default.\nAny valid HTTP headers can be defined in ",(0,i.jsx)(t.code,{children:"headers"})," if necessary, but in this context the important one is ",(0,i.jsx)(t.code,{children:"Authorization"}),".\nThese headers will be added to any request that will be executed during the test."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n  "test-runner": {\n    "headers": {\n      "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJteS10ZXN0LWlzc3VlciIsImF1ZCI6WyJteS10ZXN0LWF1ZGllbmNlIl0sImV4cCI6OTk5OTk5OTk5OSwidmFsIjoxfQ.cvgte5Lfhrsr2OPoRM9ecJbxehBQzwHaghANY6MvhqE"\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"additional-tests",children:"Additional Tests"}),"\n",(0,i.jsxs)(t.p,{children:["To be able to test different scenarios, it is mandatory to be able to provide different tokens that simulate them.\nTo achieve this, we can define any new test case under the project's ",(0,i.jsx)(t.code,{children:"test-folder"}),", the test execution will pick them up and also compare it with their respective snapshots.\nA custom JWT test case will require two files, which share the same name that will function as the name of the test case:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["A ",(0,i.jsx)(t.code,{children:".graphql"})," file that should define a query, mutation, or subscription."]}),"\n",(0,i.jsxs)(t.li,{children:["A ",(0,i.jsx)(t.code,{children:".properties"})," file if the test case requires a different token than the one defined in `test-runner"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A sample test case structure with three different test cases looks like the below file tree."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 mutationWithSameToken.graphql\n\u2502   \u251c\u2500\u2500 subscriptionWithSameToken.graphql\n\u2502   \u251c\u2500\u2500 differentUserQuery.graphql\n\u2502   \u251c\u2500\u2500 differentUserQuery.properties\n\u2502   ...\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The content of the ",(0,i.jsx)(t.code,{children:".properties"})," override the applied ",(0,i.jsx)(t.code,{children:"headers"})," tor the matching ",(0,i.jsx)(t.code,{children:".graphql"})," requests, making it possible to define different scenarios.\nA simple JWT override header properties file would look like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-properties",children:"Authorization: Bearer <test-specific-jwt>\n"})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);