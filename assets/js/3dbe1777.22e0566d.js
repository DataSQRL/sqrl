"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8015],{5863:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"interface","title":"Designing the Interface","description":"Based on the SQRL script, DataSQRL generates the interface for the compiled data pipeline. DataSQRL supports the following interfaces:","source":"@site/docs/interface.md","sourceDirName":".","slug":"/interface","permalink":"/docs/interface","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83d\udd0c Source & Sink Connectors","permalink":"/docs/connectors"},"next":{"title":"DataSQRL Configuration (package.json file)","permalink":"/docs/configuration"}}');var s=t(4848),a=t(8453);const r={},o="Designing the Interface",d={},c=[{value:"Data Products",id:"data-products",level:2},{value:"APIs",id:"apis",level:2},{value:"GraphQL",id:"graphql",level:3},{value:"Model-to-Schema Mapping",id:"model-to-schema-mapping",level:4},{value:"Base Tables",id:"base-tables",level:4},{value:"Schema Generation",id:"schema-generation",level:4},{value:"Schema Customization",id:"schema-customization",level:4},{value:"Authoritative Model",id:"authoritative-model",level:4},{value:"MCP and REST",id:"mcp-and-rest",level:3},{value:"Testing",id:"testing",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"designing-the-interface",children:"Designing the Interface"})}),"\n",(0,s.jsx)(n.p,{children:"Based on the SQRL script, DataSQRL generates the interface for the compiled data pipeline. DataSQRL supports the following interfaces:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data Product (Data Lake Views and Database Views)"}),"\n",(0,s.jsx)(n.li,{children:"GraphQL (Mutations, Queries, and Subscriptions)"}),"\n",(0,s.jsx)(n.li,{children:"MCP (Tooling and Resources)"}),"\n",(0,s.jsx)(n.li,{children:"REST (GET and POST)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For data products, DataSQRL generates view definitions as deployment assets in ",(0,s.jsx)(n.code,{children:"build/deploy/plan"})," which can be queried directly."]}),"\n",(0,s.jsxs)(n.p,{children:["The last three are APIs that can be invoked programmatically. The ",(0,s.jsx)(n.code,{children:"protocols"})," ",(0,s.jsx)(n.a,{href:"/docs/configuration#compiler-compiler",children:"compiler configuration"})," controls which API protocols are exposed by the server."]}),"\n",(0,s.jsx)(n.h2,{id:"data-products",children:"Data Products"}),"\n",(0,s.jsx)(n.p,{children:"For data products, each visible table defined in the SQRL script is exposed as a view or physical table depending on the pipeline optimization. The mapping between visible tables in the SQRL script and exposed tables in the interface is 1-to-1."}),"\n",(0,s.jsxs)(n.p,{children:["We recommend generating unique table names for the physical tables by configuring a table-name suffix in the ",(0,s.jsx)(n.a,{href:"configuration-default",children:"connector configuration"}),", e.g. by configuring the ",(0,s.jsx)(n.code,{children:"table-name"})," for ",(0,s.jsx)(n.code,{children:"postgres"})," or the ",(0,s.jsx)(n.code,{children:"catalog-table"})," for ",(0,s.jsx)(n.code,{children:"iceberg"})," to ",(0,s.jsx)(n.code,{children:"${sqrl:table-name}_MY_SUFFIX"})," . This separates views from physical tables to provide modularity and support updates without impacting downstream consumers."]}),"\n",(0,s.jsx)(n.h2,{id:"apis",children:"APIs"}),"\n",(0,s.jsx)(n.p,{children:"When a server engine is configured, the tables, relationships, and functions defined in a SQRL script map to API endpoints exposed by the server.\nDataSQRL builds an object-relationship model from the tables and relationships between them. Tables are mapped to objects with each scalar column as a field. Fields that are nested rows are mapped to child objects with field name as the parent-to-child relationship. Relationships defined between tables are mapped to relationships between the corresponding objects."}),"\n",(0,s.jsx)(n.h3,{id:"graphql",children:"GraphQL"}),"\n",(0,s.jsx)(n.p,{children:"DataSQRL uses the GraphQL data model as the base model for all API access to data because there is a natural 1-to-1 mapping between the object-relationship model of a SQRL project and GraphQL schema:\nEach object maps to a type or input and each relationship maps to a relationship field on the respective types."}),"\n",(0,s.jsx)(n.h4,{id:"model-to-schema-mapping",children:"Model-to-Schema Mapping"}),"\n",(0,s.jsxs)(n.p,{children:["Specifically, tables and functions are exposed as query endpoints of the same name and argument signature (i.e. the argument names and types match).\nTables/functions defined with the ",(0,s.jsx)(n.code,{children:"SUBSCRIBE"})," keyword are exposed as subscriptions.\nInternal table sources are exposed as mutations with the input type identical to the columns in the table excluding computed columns."]}),"\n",(0,s.jsx)(n.p,{children:"In addition, the result type of the endpoint matches the schema of the table or function. That means, each field of the result type matches a column or relationship on the table/function by name and the field type is compatible.\nThe field type is compatible with the column/relationship type iff:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For scalar or collection types there is a native mapping from one type system to the other"}),"\n",(0,s.jsx)(n.li,{children:"For structured types (i.e. nested or relationship), the mapping applies recursively."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"base-tables",children:"Base Tables"}),"\n",(0,s.jsx)(n.p,{children:"To avoid generating multiple redundant result types in the API interface, the compiler infers the base table for each defined table and function."}),"\n",(0,s.jsx)(n.p,{children:"The base table for a defined table or function is the right-most table in the relational tree of the SELECT query from the definition body if and only if that table type is equal to the defined table type. If no such table exists, the base table is the table itself."}),"\n",(0,s.jsxs)(n.p,{children:["The result type for a table or function is the result type generated for that table's base table.\nHidden columns, i.e. columns where the name starts with an underscore ",(0,s.jsx)(n.code,{children:"_"}),", are not included in the generated result type."]}),"\n",(0,s.jsx)(n.h4,{id:"schema-generation",children:"Schema Generation"}),"\n",(0,s.jsxs)(n.p,{children:["The compiler generates the GraphQL schema automatically from the SQRL script if no API schema is defined in the ",(0,s.jsx)(n.a,{href:"configuration",children:(0,s.jsx)(n.code,{children:"package.json"})}),". Add the ",(0,s.jsx)(n.code,{children:"--api graphql"})," flag to the ",(0,s.jsxs)(n.a,{href:"/docs/compiler#compile-command",children:[(0,s.jsx)(n.code,{children:"compile"})," command"]})," to write the schema to the ",(0,s.jsx)(n.code,{children:"schema.v1.graphqls"})," file in the same directory for inspection or fine-tuning."]}),"\n",(0,s.jsx)(n.h4,{id:"schema-customization",children:"Schema Customization"}),"\n",(0,s.jsx)(n.p,{children:"If a GraphQL schema is defined, the compiler maps the object-relationship model onto the provided schema. You can write your own GraphQL schema or modify the generated GraphQL schema to control the exposed interface. Any modifications must preserve the mapping to the object-relationship model described above."}),"\n",(0,s.jsx)(n.p,{children:"You can customize the GraphQL schema by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Changing field cardinalities (e.g. ",(0,s.jsx)(n.code,{children:"[Person]!"})," to ",(0,s.jsx)(n.code,{children:"Person!"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Changing scalar types (e.g. ",(0,s.jsx)(n.code,{children:"Long"})," to ",(0,s.jsx)(n.code,{children:"Int"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Changing the argument name for mutations (e.g. ",(0,s.jsx)(n.code,{children:"event"})," to ",(0,s.jsx)(n.code,{children:"payload"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Changing the type of fields to compatible types (e.g. ",(0,s.jsx)(n.code,{children:"Person"})," to ",(0,s.jsx)(n.code,{children:"SpecificPerson"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Adding enums"}),"\n",(0,s.jsx)(n.li,{children:"Adding interfaces and structuring types with interfaces"}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"The compiler raises errors when the provided GraphQL schema is not compatible with the object-relationship model."})}),"\n",(0,s.jsx)(n.h4,{id:"authoritative-model",children:"Authoritative Model"}),"\n",(0,s.jsx)(n.p,{children:"DataSQRL uses the GraphQL schemas the authoritative model for all API protocols. It serves as the foundational model on which operations, endpoints, and access patterns are defined. This simplifies the conceptual model and server execution since any API operation maps to a GraphQL query which is executed by a centralized and optimized GraphQL engine."}),"\n",(0,s.jsx)(n.p,{children:"The GraphQL query execution engine sits at the core of the DataSQRL server engine and executes all requests even if the GraphQL API is not exposed. This ensures uniform execution of all requests and a shared authentication and authorization mechanism for security."}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[Incoming Request] --\x3e B[HTTP + Authentication]\n    B --\x3e C[Router]\n    \n    C --\x3e D[GraphQL]\n    C --\x3e E[REST]\n    C --\x3e F[MCP]\n    \n    F --\x3e G[Operations]\n    E --\x3e G\n    D --\x3e H[GraphQL Query Engine]\n    G --\x3e H\n    \n    subgraph Server\n        B\n        C\n        D\n        E\n        F\n        G\n        H\n    end"}),"\n",(0,s.jsx)(n.h3,{id:"mcp-and-rest",children:"MCP and REST"}),"\n",(0,s.jsx)(n.p,{children:"DataSQRL exposes an endpoint in MCP or REST for each GraphQL operation.\nDataSQRL generates a list of operations from the GraphQL schema: one for each query and mutation endpoint."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Queries are mapped to MCP tools with a ",(0,s.jsx)(n.code,{children:"Get"})," prefix and REST endpoints under ",(0,s.jsx)(n.code,{children:"rest/queries"}),". If the arguments are simple scalars, the REST endpoint is GET with URL parameters, otherwise POST with the arguments as payload. For the result set, DataSQRL follows relationship fields up to a configured depth ",(0,s.jsx)(n.code,{children:"max-result-depth"})," (and without loops)."]}),"\n",(0,s.jsxs)(n.li,{children:["Mutations are mapped to MCP tools with an ",(0,s.jsx)(n.code,{children:"Add"})," prefix and REST POST endpoints under ",(0,s.jsx)(n.code,{children:"rest/mutations"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For complete control over the exposed MCP tools and resources as well as REST endpoints, you can define the GraphQL operations explicitly in one or multiple ",(0,s.jsx)(n.code,{children:".graphql"})," files which configured under ",(0,s.jsx)(n.code,{children:"operations"})," in the ",(0,s.jsx)(n.a,{href:"configuration",children:(0,s.jsx)(n.code,{children:"package.json"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The GraphQL file defining the operations contains named queries or mutations.\nThe name of the operation is the name of the MCP tool and REST endpoint and must be unique."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@api"})," directive is applied to the directive to control how the operation is exposed:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rest"}),": ",(0,s.jsx)(n.code,{children:"NONE"}),", ",(0,s.jsx)(n.code,{children:"GET"}),", or ",(0,s.jsx)(n.code,{children:"POST"})," to configure the HTTP method or not expose as REST endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mcp"}),": ",(0,s.jsx)(n.code,{children:"NONE"}),", ",(0,s.jsx)(n.code,{children:"TOOL"}),", or ",(0,s.jsx)(n.code,{children:"RESOURCE"})," to configure how the query is exposed in MCP."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"uri"}),": AN RFC 6570 template to configure the REST path and MCP resource path. Any operation arguments that are not defined in the uri template are considered part of the payload for REST (and the method must be POST)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'""" Returns up to 10 people for a given age """\nquery GetPersonByAge($age: Int!) @api(rest: GET, mcp: TOOL, uri: "/queries/personByAge/{age}") {\n    Person(age: $age, limit: 10, offset: 0) {\n        name\n        email\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This defines an operation ",(0,s.jsx)(n.code,{children:"GetPersonByAge"})," which is the name of the MCP tool and REST endpoint with the path ",(0,s.jsx)(n.code,{children:"/queries/personByAge/{age}"})," using GET method."]}),"\n",(0,s.jsx)(n.p,{children:"The doc strings for the operations are used in the API and tooling documentation."}),"\n",(0,s.jsxs)(n.p,{children:["By default, DataSQRL will add the custom operations to the generated ones. To only expose explicitly defined operations set ",(0,s.jsx)(n.code,{children:"endpoints"})," option to ",(0,s.jsx)(n.code,{children:"OPS_ONLY"})," in the ",(0,s.jsx)(n.a,{href:"configuration",children:(0,s.jsx)(n.code,{children:"package.json"})}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.p,{children:["DataSQRL's automated testing via the ",(0,s.jsxs)(n.a,{href:"compiler#test-command",children:[(0,s.jsx)(n.code,{children:"test"})," command"]})," executes all GraphQL queries inside the ",(0,s.jsx)(n.a,{href:"configuration",children:"configured"})," ",(0,s.jsx)(n.code,{children:"test-folder"})," and snapshots the returned results. Queries are executed in this order:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"All subscription queries are registered"}),"\n",(0,s.jsxs)(n.li,{children:["Mutations are executed sequentially in alphabetical order of filename. The test runner waits the configured ",(0,s.jsx)(n.code,{children:"mutation-delay-sec"})," between mutations. Results are written as snapshots to the snapshot folder."]}),"\n",(0,s.jsx)(n.li,{children:"The test runner waits until the configured timeout."}),"\n",(0,s.jsx)(n.li,{children:"Queries are executed and results written as snapshots."}),"\n",(0,s.jsx)(n.li,{children:"All subscription results are sorted and written as snapshots."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If a snapshot already exists, results are compared and the test fails if they are unequal."}),"\n",(0,s.jsxs)(n.p,{children:["The test runner uses the configured ",(0,s.jsx)(n.code,{children:"headers"})," for accessing the API. To test authentication and authorization with different access tokens, create a properties file with the same name as the GraphQL file to configure header properties per query."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if your test folder contains ",(0,s.jsx)(n.code,{children:"myquery.graphql"})," you can configure custom headers for this query in ",(0,s.jsx)(n.code,{children:"myquery.properties"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Authorization: Bearer XYZ\n"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);