"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5315],{7066:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"howto/subgraph-elimination","title":"Subgraph Elimination","description":"Sometimes the Flink optimizer is too smart for its own good and will push down predicates that make common subgraph identification impossible resulting in duplicate computation.","source":"@site/docs/howto/subgraph-elimination.md","sourceDirName":"howto","slug":"/howto/subgraph-elimination","permalink":"/docs/howto/subgraph-elimination","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Enriching Data Streams","permalink":"/docs/howto/stream-enrichment"},"next":{"title":"Templating","permalink":"/docs/howto/templating"}}');var o=n(4848),s=n(8453);const a={},r="Subgraph Elimination",c={},l=[];function d(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"subgraph-elimination",children:"Subgraph Elimination"})}),"\n",(0,o.jsx)(t.p,{children:"Sometimes the Flink optimizer is too smart for its own good and will push down predicates that make common subgraph identification impossible resulting in duplicate computation.\nThat can result in much larger job graphs and poor performance or high state maintenance."}),"\n",(0,o.jsxs)(t.p,{children:["To inhibit predicate pushdown, SQRL provides the ",(0,o.jsx)(t.code,{children:"noop"})," function that takes an arbitrary list of argument and always returns true.\nAs such, the function serves no purpose other than making it impossible for the optimizer to push down predicates."]}),"\n",(0,o.jsx)(t.p,{children:"Consider the following schematic example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"MyComputedTable := SELECT a, b, expensive_function(data) AS c FROM InputData;\n\nResultA := SELECT a, c FROM MyComputedTable WHERE noop(a,b,c);\nResultB := SELECT b, c FROM MyCOmputedTable WHERE noop(a,b,c);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Because ",(0,o.jsx)(t.code,{children:"ResultA"})," and ",(0,o.jsx)(t.code,{children:"ResultB"})," select different subsets of columns, those selections can get optimized down to the source ",(0,o.jsx)(t.code,{children:"InputData"})," table resulting in ",(0,o.jsx)(t.code,{children:"expensive_function"})," being executed twice because the relational trees are slightly different. By adding the ",(0,o.jsx)(t.code,{children:"noop"})," function we inhibit that push-down optimization."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);