"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[1833],{5257:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"howto/stream-enrichment","title":"Enriching Data Streams","description":"A common requirement in stream processing is to enrich a STREAM of events with dimensional data in a time-consistent manner. This pattern is particularly useful when you need to join real-time events with slowly changing dimensional data while maintaining temporal consistency.","source":"@site/docs/howto/stream-enrichment.md","sourceDirName":"howto","slug":"/howto/stream-enrichment","permalink":"/docs/howto/stream-enrichment","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Project Structure","permalink":"/docs/howto/project-structure"},"next":{"title":"Subgraph Elimination","permalink":"/docs/howto/subgraph-elimination"}}');var i=t(4848),s=t(8453);const r={},c="Enriching Data Streams",o={},l=[{value:"Use Case: Transaction Enrichment",id:"use-case-transaction-enrichment",level:2},{value:"Defining Source Tables",id:"defining-source-tables",level:2},{value:"Creating a Versioned State Table",id:"creating-a-versioned-state-table",level:2},{value:"Temporal Join for Stream Enrichment",id:"temporal-join-for-stream-enrichment",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"Variations",id:"variations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"enriching-data-streams",children:"Enriching Data Streams"})}),"\n",(0,i.jsxs)(n.p,{children:["A common requirement in stream processing is to enrich a ",(0,i.jsx)(n.strong,{children:"STREAM"})," of events with dimensional data in a time-consistent manner. This pattern is particularly useful when you need to join real-time events with slowly changing dimensional data while maintaining temporal consistency."]}),"\n",(0,i.jsx)(n.h2,{id:"use-case-transaction-enrichment",children:"Use Case: Transaction Enrichment"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose we want to enrich transaction events with the account balance that was valid ",(0,i.jsx)(n.strong,{children:"at the time of the transaction"}),". This ensures we get consistent, point-in-time data for analysis."]}),"\n",(0,i.jsx)(n.h2,{id:"defining-source-tables",children:"Defining Source Tables"}),"\n",(0,i.jsx)(n.p,{children:"First, define your data sources. These can be internal tables (managed by DataSQRL) or external tables with connector configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Transaction events stream (STREAM type)\nCREATE TABLE Transaction (\n    `txid` BIGINT NOT NULL,\n    `accountid` BIGINT NOT NULL,\n    `amount` DECIMAL(10,2) NOT NULL,\n    `timestamp` TIMESTAMP_LTZ(3) NOT NULL,\n    WATERMARK FOR `timestamp` AS `timestamp` - INTERVAL '0.001' SECOND\n);\n\n-- Account balance updates stream (STREAM type)  \nCREATE TABLE AccountBalanceUpdates (\n    `accountid` BIGINT NOT NULL,\n    `balance` DECIMAL(15,2) NOT NULL,\n    `lastUpdated` TIMESTAMP_LTZ(3) NOT NULL,\n    WATERMARK FOR `lastUpdated` AS `lastUpdated` - INTERVAL '0.001' SECOND\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-versioned-state-table",children:"Creating a Versioned State Table"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Transaction"})," table is a ",(0,i.jsx)(n.strong,{children:"STREAM"})," of immutable transaction events. The ",(0,i.jsx)(n.code,{children:"AccountBalanceUpdates"})," table is also a ",(0,i.jsx)(n.strong,{children:"STREAM"})," representing changes to account balances over time."]}),"\n",(0,i.jsxs)(n.p,{children:["To perform temporal joins, we need to convert the balance updates stream into a ",(0,i.jsx)(n.strong,{children:"VERSIONED_STATE"})," table that tracks the current and historical values for each account:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"AccountBalance := DISTINCT AccountBalanceUpdates ON accountid ORDER BY lastUpdated DESC;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This ",(0,i.jsx)(n.code,{children:"DISTINCT"})," operation:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Converts the append-only stream into a ",(0,i.jsx)(n.strong,{children:"VERSIONED_STATE"})," table"]}),"\n",(0,i.jsxs)(n.li,{children:["Deduplicates on the ",(0,i.jsx)(n.code,{children:"accountid"})," primary key"]}),"\n",(0,i.jsxs)(n.li,{children:["Orders by ",(0,i.jsx)(n.code,{children:"lastUpdated DESC"})," to ensure the most recent balance is kept for each account"]}),"\n",(0,i.jsx)(n.li,{children:"Maintains the version history for temporal lookups"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"temporal-join-for-stream-enrichment",children:"Temporal Join for Stream Enrichment"}),"\n",(0,i.jsx)(n.p,{children:"Now we can perform a temporal join to enrich each transaction with the account balance that was valid at the transaction timestamp:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EnrichedTransaction := SELECT t.*, a.balance, a.lastUpdated as balance_timestamp\n                       FROM Transaction t\n                       JOIN AccountBalance FOR SYSTEM_TIME AS OF t.`timestamp` AS a \n                       ON a.accountid = t.accountid;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"FOR SYSTEM_TIME AS OF"})," syntax ensures that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Each transaction gets the account balance that was valid at ",(0,i.jsx)(n.code,{children:"t.timestamp"})]}),"\n",(0,i.jsx)(n.li,{children:"If no balance record exists at that time, the join returns no result for that transaction"}),"\n",(0,i.jsx)(n.li,{children:"The join is temporally consistent and deterministic"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,i.jsx)(n.p,{children:"This approach provides:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Temporal Consistency"}),": Each transaction is enriched with the balance that existed at transaction time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Late Data Handling"}),": The watermark configuration allows for slightly out-of-order events"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Processing"}),": The VERSIONED_STATE table enables fast temporal lookups"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability"}),": The pattern works with high-volume streams and frequent balance updates"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"variations",children:"Variations"}),"\n",(0,i.jsx)(n.p,{children:"For different requirements, you might adjust the pattern:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Left Join"}),": Use ",(0,i.jsx)(n.code,{children:"LEFT JOIN"})," to include transactions even when no balance is available"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multiple Dimensions"}),": Join with multiple VERSIONED_STATE tables for comprehensive enrichment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Window-based Enrichment"}),": Combine with time windows for aggregated enrichment data"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);