"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8066],{4789:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"developer","title":"Developer Documentation","description":"The DataSQRL project consists of two parts:","source":"@site/docs/developer.md","sourceDirName":".","slug":"/developer","permalink":"/docs/developer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83e\udde0 Streaming Concepts","permalink":"/docs/concepts"}}');var s=t(4848),a=t(8453);const r={},o="Developer Documentation",l={},c=[{value:"DataSQRL Build Tool",id:"datasqrl-build-tool",level:2},{value:"CLI",id:"cli",level:3},{value:"Packager",id:"packager",level:4},{value:"Command Line Interface",id:"command-line-interface",level:4},{value:"Discovery",id:"discovery",level:4},{value:"Planner",id:"planner",level:3},{value:"Transpiler",id:"transpiler",level:4},{value:"Logical Plan Analyzer",id:"logical-plan-analyzer",level:4},{value:"DAG Planner",id:"dag-planner",level:4},{value:"Physical Planner",id:"physical-planner",level:4},{value:"Testing",id:"testing",level:3},{value:"DataSQRL Runtime",id:"datasqrl-runtime",level:2},{value:"Server",id:"server",level:3},{value:"Flink Libraries",id:"flink-libraries",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",div:"div",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"developer-documentation",children:"Developer Documentation"})}),"\n",(0,s.jsx)(n.p,{children:"The DataSQRL project consists of two parts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The DataSQRL build tool: Compiles SQRL script and (optional) API schema to an\nintegrated data pipeline or event-driven microservice by producing the deployment\nassets for all components of the pipeline or microservice."}),"\n",(0,s.jsx)(n.li,{children:"The DataSQRL runtime components: libraries and components that are executed\nas part of a compiled data pipeline when the deployment assets are deployed or tested."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This repository contains the entire build tool implementation and parts of the runtime split across multiple modules.\nRefer to the README.md file in each module for information on what this module contains and what its purpose is."}),"\n",(0,s.jsx)(n.p,{children:"The following repositories contain additional runtime components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/DataSQRL/flink-sql-runner",children:"Flink SQL Runner"}),": Runs the Flink compiled plan and provides additional utilities for Flink."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/DataSQRL/sqrl-k8s",children:"SQRL K8s"}),": A template for running DataSQRL pipelines in Kubernetes"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"This page is slightly out of date and will be updated for 0.6 soon."})}),"\n",(0,s.jsx)(n.p,{children:"The following diagram shows how the modules and repositories fit together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:'graph TD;\n    %% Repository Annotations\n    subgraph Repositories\n        B["\u2795 = sqrl"]\n        A["\u2b1b\ufe0e = flink-sql-runner"]\n        C["\u25b2 = sqrl-functions"]\n        D["\u26ab\ufe0e = sqrl-k8s"]\n    end\n\n    subgraph Server\n        server-core["server-core \u2795"]\n        server-vertx["server-vertx \u2795"]\n    end\n\n    %% Main Components\n    sqrl-k8s["sqrl-k8s \u26ab\ufe0e"]\n    flink-sql-run["sql-run (light) \u2b1b\ufe0e "]\n    sqrl-exec["sqrl-exec \u2795"]\n    sqrl-cli["sqrl-cli \u2795"]\n    sqrl-planner["sqrl-planner \u2795"]\n    sqrl-integration-test["sqrl-integration-test\u2795"]\n    sqrl-lib-common["sqrl-lib-common (light) \u2b1b\ufe0e"]\n    sqrl-common["sqrl-common (light) \u2795"]\n    std-library-functions["Std library functions \u2795"]\n    formats-connectors["Formats & Connectors \u2b1b\ufe0e"]\n    sqrl-functions["sqrl-functions \u25b2"]\n\n    %% Relationships\n    sqrl-lib-common --\x3eflink-sql-run\n    sqrl-lib-common --\x3esqrl-common\n    sqrl-lib-common --\x3e std-library-functions\n    sqrl-lib-common --\x3e formats-connectors\n    sqrl-lib-common --\x3e sqrl-functions\n\n    flink-sql-run --\x3e sqrl-k8s\n    flink-sql-run --\x3e sqrl-exec\n\n    sqrl-common --\x3e sqrl-planner\n    sqrl-common --\x3e server-core\n\n    server-core --\x3e server-vertx\n    sqrl-exec --\x3e sqrl-integration-test\n    sqrl-planner --\x3e sqrl-cli\n    sqrl-cli --\x3e sqrl-integration-test\n'})}),"\n",(0,s.jsx)(n.h2,{id:"datasqrl-build-tool",children:"DataSQRL Build Tool"}),"\n",(0,s.jsx)(n.p,{children:"The goal of the DataSQRL build tool is simplifying the development of data pipelines\nand event-driven microservices. Developers implement the logic of their\ndata product in SQL. The build tool compiles the SQL into an integrated\ndata pipeline that ingests, processes, stores, and serves the data as defined."}),"\n",(0,s.jsxs)(n.p,{children:["DataSQRL has its own variant of SQL called SQRL. SQRL extends SQL to allow\nexplicit imports and nested tables to represent hierarchical data natively. It\nalso provides some syntactic sugar to make it more convenient to develop with SQL.\nRead the ",(0,s.jsx)(n.a,{href:"sqrl-language",children:"SQRL specification"})," for more details."]}),"\n",(0,s.jsx)(n.p,{children:"DataSQRL supports a pluggable engine architecture. A data pipeline or microservice\nconsists of multiple stages and each stage is executed by an engine.\nFor example, a data pipeline may consist of a stream processing, storage, and\nserving stage which are executed by Apache Flink, PostgreSQL, and Vert.x, respectively."}),"\n",(0,s.jsx)(n.p,{children:"DataSQRL supports the following types of stages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stream Processing: For processing data as it is ingested"}),"\n",(0,s.jsx)(n.li,{children:"Log: For moving data between stages reliably"}),"\n",(0,s.jsx)(n.li,{children:"Database: For storage and querying data"}),"\n",(0,s.jsx)(n.li,{children:"Server: For returning data through an API upon request"}),"\n",(0,s.jsx)(n.li,{children:"Cache: For caching data on the server (coming soon)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'A data pipeline topology is a sequence of stages. A pipeline topology may contain\nmultiple stages of the same type (e.g. two different database stages).\nAn engine is what executes the deployment assets for a given stage.\nFor example, the FlinkSQL generated by the compiler as part of the deployment assets for the "stream" stage is\nexecuted by the Flink engine.'}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline topology as well as other compiler configuration options are\nspecified in a json configuration file typically called ",(0,s.jsx)(n.code,{children:"package.json"}),".\nThe ",(0,s.jsx)(n.a,{href:"/docs/configuration",children:"configuration documentation"})," lists all the configuration options."]}),"\n",(0,s.jsx)(n.p,{children:"In addition to the compiler, the DataSQRL build tool contains a package manager\nfor resolving external data and\nfunction dependencies, pre-processors for preparing dependencies, and post-processors\nfor refining the deployment artifacts produced by the compiler to the specified\nengine configuration."}),"\n",(0,s.jsx)(n.p,{children:"The DataSQRL build tool consists of the following components (i.e. java modules),\nlisted in the order in which they are invoked when compiling a SQRL script:"}),"\n",(0,s.jsx)(n.h3,{id:"cli",children:"CLI"}),"\n",(0,s.jsx)(n.h4,{id:"packager",children:"Packager"}),"\n",(0,s.jsxs)(n.p,{children:["The packager prepares the build directory for the compiler. The job of the\npackager is to populate the ",(0,s.jsx)(n.code,{children:"build"})," directory with all the files needed by the\ncompiler, so that the compiler can operate exclusively on the build directory and\nhave all the files it needs prepared in a standard way."]}),"\n",(0,s.jsx)(n.p,{children:"The packager\nresolves external data and function dependencies that are imported in a script.\nThose are either resolved against the local filesystem or downloaded from a repository\nand placed into the build directory."}),"\n",(0,s.jsx)(n.p,{children:"The packager also runs all registered pre-processors on the local directory\nto pre-process input files and place them into the build directory for the\ncompiler. DataSQRL has a generic pre-processor framework."}),"\n",(0,s.jsx)(n.h4,{id:"command-line-interface",children:"Command Line Interface"}),"\n",(0,s.jsxs)(n.p,{children:["The DataSQRL build tool is accessed through a command line interface.\nIt defines all of the commands that DataSQRL supports and provides\nusability features to help the user and produce useful error messages.\nSee the ",(0,s.jsx)(n.a,{href:"compiler",children:"CLI documentation"})," for more information."]}),"\n",(0,s.jsx)(n.h4,{id:"discovery",children:"Discovery"}),"\n",(0,s.jsx)(n.p,{children:"The build tool contains a separate piece of functionality for data discovery.\nThe goal for data discovery is to make it easy for new users to get started\nwith DataSQRL by automatically generating table definitions for users' data."}),"\n",(0,s.jsxs)(n.p,{children:["This is implemented as a pre-processor that automatically extracts a schema\nfrom ",(0,s.jsx)(n.code,{children:"jsonl"})," and ",(0,s.jsx)(n.code,{children:"csv"})," files and generates a table definition with connector\ninformation for such files."]}),"\n",(0,s.jsx)(n.h3,{id:"planner",children:"Planner"}),"\n",(0,s.jsx)(n.p,{children:"The planner parses a SQRL script, i.e. a sequence of SQL(ish) statements, analyzes\nthe statements, constructs a data processing DAG, optimizes the DAG, and finally\nproduces deployment assets for the engines executing the data processing steps."}),"\n",(0,s.jsx)(n.p,{children:"The planner consists of the following components."}),"\n",(0,s.jsx)(n.h4,{id:"transpiler",children:"Transpiler"}),"\n",(0,s.jsx)(n.p,{children:'The transpiler is the first stage of the compiler. The transpiler parses the\nSQRL script into a logical plan by "translating" the SQRL specific SQL syntax\ninto FlinkSQL.'}),"\n",(0,s.jsx)(n.p,{children:"The transpiler resolves imports against the build directory using module loaders\nthat retrieve dependencies. It maintains a schema of all defined tables\nin a SQRL script. It also parses the API specification and maps the API schema\nthe table schemas."}),"\n",(0,s.jsx)(n.p,{children:"The transpiler is build on top of Apache Calcite by way of FlinkSQL for all SQL handling.\nIt prepares the statements that are analyzed and planned by the planner"}),"\n",(0,s.jsx)(n.h4,{id:"logical-plan-analyzer",children:"Logical Plan Analyzer"}),"\n",(0,s.jsx)(n.p,{children:"The logical plan analyzer is the second stage of the compiler. It takes the\nlogical plan (i.e. Relnode) produced by the transpiler for each table or function\ndefined in the SQRL script and analyzes the logical plan to extract a TableAnalysis\nthat contains information needed by the planner."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"It keeps track of important metadata like timestamps, primary keys, sort orders, etc"}),"\n",(0,s.jsx)(n.li,{children:"It analyzes the SQL to identify potential issues, semantic inconsistencies, or optimization potential and produces warnings or notices."}),"\n",(0,s.jsx)(n.li,{children:"It extracts cost information for the optimizer."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"dag-planner",children:"DAG Planner"}),"\n",(0,s.jsx)(n.p,{children:"The DAG planner takes all the individual table and function definitions and assembles them into\na data processing DAG (directed acyclic graph). It prunes the DAG and rewrites the DAG before optimizing the\nDAG to assign each node (i.e. table or function) to a stage in the pipeline."}),"\n",(0,s.jsx)(n.p,{children:"The optimizer uses a cost model and is constrained to produce only viable\npipelines."}),"\n",(0,s.jsx)(n.p,{children:"At the end of the DAG planning process, each table or function defined in the SQRL script\nis assigned to a stage in the pipeline."}),"\n",(0,s.jsx)(n.h4,{id:"physical-planner",children:"Physical Planner"}),"\n",(0,s.jsx)(n.p,{children:"All the tables in a given stage are then passed to the stage engine's physical\nplanner which produces the physical plan for the engine that has been\nconfigured to execute that stage."}),"\n",(0,s.jsx)(n.p,{children:"Physical planning can contain additional optimization such as selecting optimal index\nstructures for database tables."}),"\n",(0,s.jsx)(n.p,{children:"The physical planner is also responsible for generating the API schemas (e.g. GraphQL schema)\nfor the exposed API if the pipeline contains a server engine. Optionally, the user may\nprovide the API schema in which case the physical planner validates the schema and maps it\nto the SQRL script."}),"\n",(0,s.jsxs)(n.p,{children:["The physical plans are then written out as deployment artifacts to the ",(0,s.jsx)(n.code,{children:"build/plan"}),"\ndirectory."]}),"\n",(0,s.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.p,{children:["Integration tests for the DataSQRL build tool can be found in\n",(0,s.jsx)(n.code,{children:"sqrl-testing/sqrl-integration-tests"})]}),"\n",(0,s.jsx)(n.h2,{id:"datasqrl-runtime",children:"DataSQRL Runtime"}),"\n",(0,s.jsx)(n.p,{children:"The DataSQRL project also contains some runtime components that get executed\nas part of the data pipeline compiled by the DataSQRL build tool:"}),"\n",(0,s.jsx)(n.h3,{id:"server",children:"Server"}),"\n",(0,s.jsx)(n.p,{children:"The server module contains the default server implemented based on Vert.x.\nThe server takes a configuration file as input which maps each API entry point\nto a single or set of SQL queries that are executed against the database on\nrequest."}),"\n",(0,s.jsx)(n.p,{children:"The server processes mutations by creating events and persisting them to a log.\nThe server handles subscriptions by listening to new log events and forwarding\nthem to clients."}),"\n",(0,s.jsx)(n.p,{children:'The configuration file that defines the behavior of the server is a\ndeployment asset produced by the DataSQRL build tool for the "server" stage.'}),"\n",(0,s.jsx)(n.h3,{id:"flink-libraries",children:"Flink Libraries"}),"\n",(0,s.jsxs)(n.p,{children:["DataSQRL extends the standard SQL function library with many additional function\nmodules. Those are executed at runtime in Flink or on the server.\nThe functions are iplemented in the ",(0,s.jsx)(n.code,{children:"sqrl-flink-lib"})," module."]}),"\n",(0,s.jsx)(n.p,{children:"It also contains custom formats and connectors for Flink that extend\nexisting formats and connectors to support functionality needed by DataSQRL.\nIt may be reasonable to contribute those improvements and extensions back to\nthe Apache Flink project."}),"\n",(0,s.jsx)(n.h1,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"SQRL adds additional functions to the standard SQL function catalog."}),"\n",(0,s.jsx)(n.p,{children:"Functions in SQRL are designed to be engine-agnostic, ensuring that their implementation is consistent across different platforms and execution environments. This uniformity is crucial for maintaining the semantic integrity of functions when executed under various systems."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Characteristics of Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Engine Agnosticism"}),": Functions are defined in a way that does not depend on the specifics of the underlying engine."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Semantic Consistency"}),": Regardless of the engine used, function should preserve their semantic meaning."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mixed Engine Support"}),": While functions are designed to be widely supported, some may have mixed support depending on the engine's capabilities."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nullability Awareness"}),": Functions in SQRL retain nullability information. This feature is vital for correct schema generation downstream, ensuring that data integrity is maintained through the potential propagation of null values."]}),"\n"]}),"\n",(0,s.jsx)(n.div,{children:(0,s.jsx)(n.p,{children:"This documentation is work-in-progress. SQRL does not yet support function mappings for all engines. Stay tuned."})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);